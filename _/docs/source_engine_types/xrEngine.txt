
struct Flight
{
public:
	u32 type; /* Type of light source */
	Fcolor diffuse; /* Diffuse color of light */
	Fcolor specular; /* Specular color of light */
	Fcolor ambient; /* Ambient color of light */
	Fvector position; /* Position in world space */
	Fvector direction; /* Direction in world space */
	float range; /* Cutoff range */
	float falloff; /* Falloff */
	float attenuation0; /* Constant attenuation */
	float attenuation1; /* Linear attenuation */
	float attenuation2; /* Quadratic attenuation */
	float theta; /* Inner angle of spotlight cone */
	float phi; /* Outer angle of spotlight cone */

	void set(u32 ltType, float x, float y, float z);
	void mul(float brightness);
};

struct Fmaterial
{
public:
	Fcolor diffuse; /* Diffuse color RGBA */
	Fcolor ambient; /* Ambient color RGB */
	Fcolor specular; /* Specular 'shininess' */
	Fcolor emissive; /* Emissive color RGB */
	float power; /* Sharpness if specular highlight */

	void set(float r, float g, float b);
	void set(float r, float g, float b, float a);
	void set(Fcolor& c);
};

struct VDeclarator : public svector<D3DVERTEXELEMENT9, MAXD3DDECLLENGTH + 1>
{
	void set(u32 FVF);
	void set(D3DVERTEXELEMENT9* dcl);
	void set(const VDeclarator& d);
	u32 vertex();
	BOOL equal(VDeclarator& d);
};

class AchievementManager final {
public:
    ~AchievementManager() = default;

    void SetUserAchievement(Snowflake achievementId, std::uint8_t percentComplete, std::function<void(Result)> callback);
    void FetchUserAchievements(std::function<void(Result)> callback);
    void CountUserAchievements(std::int32_t* count);
    Result GetUserAchievement(Snowflake userAchievementId, UserAchievement* userAchievement);
    Result GetUserAchievementAt(std::int32_t index, UserAchievement* userAchievement);
    Event<UserAchievement const&> OnUserAchievementUpdate;

private:
    friend class Core;

    AchievementManager() = default;
    AchievementManager(AchievementManager const& rhs) = delete;
    AchievementManager& operator=(AchievementManager const& rhs) = delete;
    AchievementManager(AchievementManager&& rhs) = delete;
    AchievementManager& operator=(AchievementManager&& rhs) = delete;

    IDiscordAchievementManager* internal_;
    static IDiscordAchievementEvents events_;
};

class ActivityManager final 
{
public:
    ~ActivityManager() = default;

    Result RegisterCommand(char const* command);
    Result RegisterSteam(std::uint32_t steamId);
    void UpdateActivity(Activity const& activity, std::function<void(Result)> callback);
    void ClearActivity(std::function<void(Result)> callback);
    void SendRequestReply(UserId userId, ActivityJoinRequestReply reply, std::function<void(Result)> callback);
    void SendInvite(UserId userId, ActivityActionType type, char const* content, std::function<void(Result)> callback);
    void AcceptInvite(UserId userId, std::function<void(Result)> callback);

    Event<char const*> OnActivityJoin;
    Event<char const*> OnActivitySpectate;
    Event<User const&> OnActivityJoinRequest;
    Event<ActivityActionType, User const&, Activity const&> OnActivityInvite;

private:
    friend class Core;

    ActivityManager() = default;
    ActivityManager(ActivityManager const& rhs) = delete;
    ActivityManager& operator=(ActivityManager const& rhs) = delete;
    ActivityManager(ActivityManager&& rhs) = delete;
    ActivityManager& operator=(ActivityManager&& rhs) = delete;

    IDiscordActivityManager* internal_;
    static IDiscordActivityEvents events_;
};

class ActivityEvents final 
{
public:
    static void OnActivityJoin(void* callbackData, char const* secret);
    static void OnActivitySpectate(void* callbackData, char const* secret);
    static void OnActivityJoinRequest(void* callbackData, DiscordUser* user);
    static void OnActivityInvite(void* callbackData, EDiscordActivityActionType type, DiscordUser* user, DiscordActivity* activity);
};

class AchievementEvents final 
{
public:
    static void OnUserAchievementUpdate(void* callbackData, DiscordUserAchievement* userAchievement);
};

enum ELuaMessageType
{
	eLuaMessageTypeInfo = u32(0),
	eLuaMessageTypeError,
	eLuaMessageTypeMessage,
	eLuaMessageTypeHookCall,
	eLuaMessageTypeHookReturn,
	eLuaMessageTypeHookLine,
	eLuaMessageTypeHookCount,
	eLuaMessageTypeHookTailReturn = u32(-1),
};

typedef lua_State CLuaVirtualMachine;

struct SMemberCallback
{
	luabind::functor<void>* m_lua_function;
	luabind::object* m_lua_object;
	shared_str m_method_name;
};

class ApplicationManager final 
{
public:
    ~ApplicationManager() = default;

    void ValidateOrExit(std::function<void(Result)> callback);
    void GetCurrentLocale(char locale[128]);
    void GetCurrentBranch(char branch[4096]);
    void GetOAuth2Token(std::function<void(Result, OAuth2Token const&)> callback);
    void GetTicket(std::function<void(Result, char const*)> callback);

private:
    friend class Core;

    ApplicationManager() = default;
    ApplicationManager(ApplicationManager const& rhs) = delete;
    ApplicationManager& operator=(ApplicationManager const& rhs) = delete;
    ApplicationManager(ApplicationManager&& rhs) = delete;
    ApplicationManager& operator=(ApplicationManager&& rhs) = delete;

    IDiscordApplicationManager* internal_;
    static IDiscordApplicationEvents events_;
};

typedef BoneCallbackFunction* BoneCallback;

class CBoneInstance
{
public:
	BoneCallback callback();
	void* callback_param();
	BOOL callback_overwrite();
	u32 callback_type();  
	void construct();
	void set_callback(u32 Type, BoneCallback C, void* Param, BOOL overwrite = FALSE);
	void reset_callback();
	void set_callback_overwrite(BOOL v);
	void set_param(u32 idx, float data);
	float get_param(u32 idx);
	u32 mem_usage();
  
public:
	Fmatrix mTransform; // final x-form matrix (local to model)
	Fmatrix mRenderTransform; // final x-form matrix (model_base -> bone -> model)
	Fmatrix mRenderTransform_prev; // Prev x-form matrix
	Fmatrix mRenderTransform_temp; // Temp var
  float param[MAX_BONE_PARAMS]; //  
  
private:
	BoneCallback Callback;
	void* Callback_Param;
	BOOL Callback_overwrite; // performance hint - don't calc anims
	u32 Callback_type;	
};

struct vertBoned1W
{
	Fvector P;
	Fvector N;
	Fvector T;
	Fvector B;
	float u, v;
	u32 matrix;
	void get_pos(Fvector& p) const;
  static const u8 bones_count = 1;
  u16 get_bone_id(u8 bone) const;
};

struct vertBoned2W
{
	u16 matrix0;
	u16 matrix1;
	Fvector P;
	Fvector N;
	Fvector T;
	Fvector B;
	float w;
	float u, v;
	void get_pos(Fvector& p) const;
  static const u8 bones_count = 2;
  u16 get_bone_id(u8 bone) const;
};

struct vertBoned3W
{
	u16 m[3];
	Fvector P;
	Fvector N;
	Fvector T;
	Fvector B;
	float w[2];
	float u, v;
	void get_pos(Fvector& p) const;
  static const u8 bones_count = 3;
  u16 get_bone_id(u8 bone) const;
};

struct vertBoned4W
{
	u16 m[4];
	Fvector P;
	Fvector N;
	Fvector T;
	Fvector B;
	float w[3];
	float u, v;
	void get_pos(Fvector& p) const;
  static const u8 bones_count = 4;
  u16 get_bone_id(u8 bone) const;
};

enum EJointType
{
	jtRigid,
	jtCloth,
	jtJoint,
	jtWheel,
	jtNone,
	jtSlider,
	jtForceU32 = u32(-1)
};

struct SJointLimit
{
	Fvector2 limit;
	float spring_factor;
	float damping_factor;
  
	SJointLimit();
	void Reset();
};

enum EShapeType
{
  stNone,
  stBox,
  stSphere,
  stCylinder,
  stForceU32 = u16(-1)
};

enum EShapeFlags
{
  sfNoPickable = (1 << 0),
  sfRemoveAfterBreak = (1 << 1),
  sfNoPhysics = (1 << 2),
  sfNoFogCollider = (1 << 3),
};

struct SBoneShape
{
	u16 type; // 2
	Flags16 flags; // 2
	Fobb box; // 15*4
	Fsphere sphere; // 4*4
	Fcylinder cylinder; // 8*4
  
	SBoneShape();
	void Reset();
	bool Valid();
};

struct SJointIKData
{
	EJointType type;
	SJointLimit limits[3];
	float spring_factor;
	float damping_factor;
	Flags32 ik_flags;
	float break_force;
	float break_torque;
	float friction;
  
  const u32 flBreakable = (1 << 0);

	SJointIKData();
	void Reset();
	void clamp_by_limits(Fvector& dest_xyz);
	void Export(IWriter& F);
	bool Import(IReader& F, u16 vers);
};

class IBoneData
{
public:

	virtual IBoneData& _BCL GetChild(u16 id) = 0;
	virtual const IBoneData& _BCL GetChild(u16 id) const = 0;
	virtual u16 _BCL GetSelfID() const = 0;
	virtual u16 _BCL GetNumChildren() const = 0;

	virtual const SJointIKData& _BCL get_IK_data() const = 0;
	virtual const Fmatrix& _BCL get_bind_transform() const = 0;
	virtual const SBoneShape& _BCL get_shape() const = 0;
	virtual const Fobb& _BCL get_obb() const = 0;
	virtual const Fvector& _BCL get_center_of_mass() const = 0;
	virtual float _BCL get_mass() const = 0;
	virtual u16 _BCL get_game_mtl_idx() const = 0;
	virtual u16 _BCL GetParentID() const = 0;
	virtual float _BCL lo_limit(u8 k) const = 0;
	virtual float _BCL hi_limit(u8 k) const = 0;
};

class CBone :	public CBoneInstance,	public IBoneData
{
public:
	int SelfID;
	CBone* parent;
	BoneVec children;
	Flags8 flags;
  const u32 flSelected = (1 << 0);
	SJointIKData IK_data;
	shared_str game_mtl;
	SBoneShape shape;
	float mass;
	Fvector center_of_mass;
  
public:
	CBone();
	virtual ~CBone();
	void SetName(const char* p);
	void SetParentName(const char* p);
	void SetWMap(const char* p);
	void SetRestParams(float length, const Fvector& offset, const Fvector& rotate);
	shared_str Name();
	shared_str ParentName();
	shared_str WMap();
	CBone* Parent();
	BOOL IsRoot();
	shared_str& NameRef();

	const Fvector& _Offset();
	const Fvector& _Rotate();
	float _Length();
	Fmatrix& _RTransform();
	Fmatrix& _RITransform();
	Fmatrix& _LRTransform();
	Fmatrix& _MTransform();
	Fmatrix& _LTransform();
	const Fmatrix& _LTransform() const;
	Fmatrix& _RenderTransform();
	Fvector& _RestOffset();
	Fvector& _RestRotate();

	void _Update(const Fvector& T, const Fvector& R);
	void Reset();
	void Save(IWriter& F);
	void Load_0(IReader& F);
	void Load_1(IReader& F);
	float _BCL engine_lo_limit(u8 k) const;
	float _BCL engine_hi_limit(u8 k) const;
	float _BCL editor_lo_limit(u8 k) const;
	float _BCL editor_hi_limit(u8 k) const;
	void SaveData(IWriter& F);
	void LoadData(IReader& F);
	void ResetData();
	void CopyData(CBone* bone);

private:
	IBoneData& GetChild(u16 id);
	const IBoneData& GetChild(u16 id) const;
	u16 GetSelfID() const;
	u16 GetNumChildren() const;
	const SJointIKData& get_IK_data() const;
	const Fmatrix& get_bind_transform() const;
	const SBoneShape& get_shape() const;
	const Fobb& get_obb() const;
	const Fvector& get_center_of_mass() const;
	float get_mass() const;
	u16 get_game_mtl_idx() const;
	u16 GetParentID() const;
	float lo_limit(u8 k) const;
	float hi_limit(u8 k) const;
  
private:
	shared_str name;
	shared_str parent_name;
	shared_str wmap;
	Fvector rest_offset;
	Fvector rest_rotate; // XYZ format (Game format)
	float rest_length;
	Fvector mot_offset;
	Fvector mot_rotate; // XYZ format (Game format)
	float mot_length;
	Fmatrix mot_transform;
	Fmatrix local_rest_transform;
	Fmatrix rest_transform;
	Fmatrix rest_i_transform;
};

typedef xr_vector<CBoneData*> vecBones;
typedef vecBones::iterator vecBonesIt;
typedef svector<int, 128> BoneDebug;

class CBoneData :	public IBoneData
{
protected:
	u16 SelfID;
	u16 ParentID;
  
public:
	shared_str name;
	Fobb obb;
	Fmatrix bind_transform;
	Fmatrix m2b_transform; // model to bone conversion transform
	SBoneShape shape;
	shared_str game_mtl_name;
	u16 game_mtl_idx;
	SJointIKData IK_data;
	float mass;
	Fvector center_of_mass;
	vecBones children; // bones which are slaves to this
	DEFINE_VECTOR(u16, FacesVec, FacesVecIt);
	DEFINE_VECTOR(FacesVec, ChildFacesVec, ChildFacesVecIt);
	ChildFacesVec child_faces; // shared
  
public:
	CBoneData(u16 ID) : SelfID(ID);
	virtual ~CBoneData();  
  void DebugQuery(BoneDebug& L);
	void SetParentID(u16 id);
	u16 GetSelfID() const;
	u16 GetParentID() const;
	void AppendFace(u16 child_idx, u16 idx);
	void CalculateM2B(const Fmatrix& Parent);
  virtual u32 mem_usage();
  
private:
	IBoneData& _BCL GetChild(u16 id);
	const IBoneData& _BCL GetChild(u16 id) const;
	u16 _BCL GetNumChildren() const;
	const SJointIKData& _BCL get_IK_data() const;
	const Fmatrix& _BCL get_bind_transform() const;
	const SBoneShape& _BCL get_shape() const;
	const Fobb& _BCL get_obb() const;
	const Fvector& _BCL get_center_of_mass() const;
	float _BCL get_mass() const;
	u16 _BCL get_game_mtl_idx() const;
	float _BCL lo_limit(u8 k) const;
	float _BCL hi_limit(u8 k) const;
};

enum EBoneCallbackType
{
	bctDummy = u32(0),
	bctPhysics,
	bctCustom,
	bctForceU32 = u32(-1),
};

enum
{
  flRelativeLink = (1 << 0),
  flPositionRigid = (1 << 1),
  flDirectionRigid = (1 << 2),
};

class CCameraBase
{
protected:
	CObject* parent;

public:
	BOOL bClampYaw, bClampPitch, bClampRoll;
	float yaw, pitch, roll;
	Flags32 m_Flags;
	ECameraStyle style;
	Fvector2 lim_yaw, lim_pitch, lim_roll;
	Fvector rot_speed;
	Fvector vPosition;
	Fvector vDirection;
	Fvector vNormal;
	float f_fov;
	float f_aspect;
  int tag;

public:
	Fvector Position() const;
	Fvector Direction() const;
	Fvector Up() const;
	Fvector Right() const;
	float Fov() const;
	float Aspect() const;  

	CCameraBase(CObject* p, u32 flags);
	virtual ~CCameraBase();
	virtual void Load(LPCSTR section);
	void SetParent(CObject* p);
	virtual void OnActivate(CCameraBase* old_cam);
	virtual void OnDeactivate();
	virtual void Move(int cmd, float val = 0, float factor = 1.0f);
	virtual void Update(Fvector& point, Fvector& noise_angle);
	virtual void Get(Fvector& P, Fvector& D, Fvector& N);
	virtual void Set(const Fvector& P, const Fvector& D, const Fvector& N);
	virtual void Set(float Y, float P, float R);
	virtual float GetWorldYaw();
	virtual float GetWorldPitch();
	virtual float CheckLimYaw();
	virtual float CheckLimPitch();
	virtual float CheckLimRoll();
};

structSBaseEffector
{
	typedef fastdelegate::FastDelegate0<> CB_ON_B_REMOVE;
	CB_ON_B_REMOVE m_on_b_remove_callback;
	virtual ~SBaseEffector();
};

struct SCamEffectorInfo
{
	Fvector p;
	Fvector d;
	Fvector n;
	Fvector r;
	float fFov;
	float fFar;
	float fAspect;
	bool dont_apply;
	bool affected_on_hud;
	SCamEffectorInfo();

	SCamEffectorInfo& operator =(const SCamEffectorInfo& other);
};

enum ECameraStyle
{
	csCamDebug,
	csFirstEye,
	csLookAt,
	csMax,
	csFixed,
	cs_forcedword = u32(-1)
};

enum ECamEffectorType
{
	cefDemo = 0,
	cefNext
};

enum EEffectorPPType
{
	ppeNext = 0,
};

struct SNoise
	{
		float intensity, grain;
		float fps;

		SNoise();
		SNoise(float _i, float _g, float _f) : intensity(_i), grain(_g), fps(_f);
		IC SNoise& set(float _i, float _g, float _f);
	};
  
struct SDuality
{
  float h, v;

  SDuality();
  SDuality(float _h, float _v) : h(_h), v(_v);
  SDuality& set(float _h, float _v);
}
  
struct SColor
{
  float r, g, b;

  SColor();
  SColor(float _r, float _g, float _b) : r(_r), g(_g), b(_b);
  operator u32();
  operator const Fvector&();
  SColor& operator +=(const SColor& ppi);
  SColor& operator -=(const SColor& ppi);
  SColor& set(float _r, float _g, float _b);
};

struct SPPInfo
{
	float blur, gray;
	SDuality duality;
  SNoise noise;
	SColor color_base;
	SColor color_gray;
	SColor color_add;
	float cm_influence;
	float cm_interpolate;
	shared_str cm_tex1;
	shared_str cm_tex2;

	SPPInfo& add(const SPPInfo& ppi);
	SPPInfo& sub(const SPPInfo& ppi);
	void normalize();
	SPPInfo();
	SPPInfo& lerp(const SPPInfo& def, const SPPInfo& to, float factor);
	void validate(LPCSTR str);
};

class CCameraManager
{  
public:
  u32 dbg_upd_frame;

	void Dump();
	u32 Count() { return m_EffectorsCam.size() + m_EffectorsCam_added_deffered.size(); }
	CEffectorCam* AddCamEffector(CEffectorCam* ef);
	CEffectorCam* GetCamEffector(ECamEffectorType type);
	void RemoveCamEffector(ECamEffectorType type);
	void RemoveCamEffector(CEffectorCam* ef);
	ECamEffectorType RequestCamEffectorId();
	EEffectorPPType RequestPPEffectorId();
	CEffectorPP* GetPPEffector(EEffectorPPType type);
	CEffectorPP* AddPPEffector(CEffectorPP* ef);
	void RemovePPEffector(EEffectorPPType type);

	Fvector Position() const;
	Fvector Direction() const;
	Fvector Up() const;
	Fvector Right() const;
	float Fov() const;
	float Aspect() const;
	void camera_Matrix(Fmatrix& M);
	void Update(const Fvector& P, const Fvector& D, const Fvector& N, float fFOV_Dest, float fASPECT_Dest,  float fFAR_Dest, u32 flags);
	void UpdateFromCamera(const CCameraBase* C);
	void ApplyDevice(float _viewport_near);
	static void ResetPP();
  
	CCameraManager(bool bApplyOnUpdate);
	virtual ~CCameraManager();
  
protected:
	SCamEffectorInfo m_cam_info;
	EffectorCamVec m_EffectorsCam;
	EffectorCamVec m_EffectorsCam_added_deffered;
	EffectorPPVec m_EffectorsPP;
	bool m_bAutoApply;
	SPPInfo pp_affected;
	void UpdateDeffered();

	virtual void UpdateCamEffectors();
	virtual void UpdatePPEffectors();
	virtual bool ProcessCameraEffector(CEffectorCam* eff);
	void OnEffectorReleased(SBaseEffector* e);  
};

class CCF_DynamicMesh :	public CCF_Skeleton
{  
public:
	CCF_DynamicMesh(CObject* _owner) : CCF_Skeleton(_owner);
	virtual BOOL _RayQuery(const collide::ray_defs& Q, collide::rq_results& R);
  
private:
	typedef CCF_Skeleton inherited;
};

class Core final 
{
public:
    static Result Create(ClientId clientId, std::uint64_t flags, Core** instance);
    ~Core();
    Result RunCallbacks();
    void SetLogHook(LogLevel minLevel, std::function<void(LogLevel, char const*)> hook);

    discord::ApplicationManager& ApplicationManager();
    discord::UserManager& UserManager();
    discord::ImageManager& ImageManager();
    discord::ActivityManager& ActivityManager();
    discord::RelationshipManager& RelationshipManager();
    discord::LobbyManager& LobbyManager();
    discord::NetworkManager& NetworkManager();
    discord::OverlayManager& OverlayManager();
    discord::StorageManager& StorageManager();
    discord::StoreManager& StoreManager();
    discord::VoiceManager& VoiceManager();
    discord::AchievementManager& AchievementManager();

private:
    Core() = default;
    Core(Core const& rhs) = delete;
    Core& operator=(Core const& rhs) = delete;
    Core(Core&& rhs) = delete;
    Core& operator=(Core&& rhs) = delete;

    IDiscordCore* internal_;
    Event<LogLevel, char const*> setLogHook_;
    discord::ApplicationManager applicationManager_;
    discord::UserManager userManager_;
    discord::ImageManager imageManager_;
    discord::ActivityManager activityManager_;
    discord::RelationshipManager relationshipManager_;
    discord::LobbyManager lobbyManager_;
    discord::NetworkManager networkManager_;
    discord::OverlayManager overlayManager_;
    discord::StorageManager storageManager_;
    discord::StoreManager storeManager_;
    discord::VoiceManager voiceManager_;
    discord::AchievementManager achievementManager_;
};

class CCustomHUD : public DLL_Pure, public IEventReceiver,	public pureScreenResolutionChanged
{
public:
	CCustomHUD();
	virtual ~CCustomHUD();

	virtual void Render_First();
	virtual void Render_Last();
	virtual void Render_Actor_Shadow();
	virtual void OnFrame();
	virtual void OnEvent(EVENT E, u64 P1, u64 P2);
	virtual void Load();
  
	virtual void OnDisconnected() = 0;
	virtual void OnConnected() = 0;
	virtual void RenderActiveItemUI() = 0;
	virtual bool RenderActiveItemUIQuery() = 0;
	virtual void net_Relcase(CObject* object) = 0;
};

enum
{
	rsFullscreen = (1ul << 0ul),
	rsClearBB = (1ul << 1ul),
	rsVSync = (1ul << 2ul),
	rsWireframe = (1ul << 3ul),
	rsOcclusion = (1ul << 4ul),
	rsStatistic = (1ul << 5ul),
	rsDetails = (1ul << 6ul),
	rsRefresh60hz = (1ul << 7ul),
	rsConstantFPS = (1ul << 8ul),
	rsDrawStatic = (1ul << 9ul),
	rsDrawDynamic = (1ul << 10ul),
	rsDisableObjectsAsCrows = (1ul << 11ul),
	rsOcclusionDraw = (1ul << 12ul),
	rsOcclusionStats = (1ul << 13ul),
	mtSound = (1ul << 14ul),
	mtPhysics = (1ul << 15ul),
	mtNetwork = (1ul << 16ul),
	mtParticles = (1ul << 17ul),
	rsCameraPos = (1ul << 18ul),
	rsR2 = (1ul << 19ul),
	rsR3 = (1ul << 20ul),
	rsR4 = (1ul << 21ul)
};

enum
{
	rsClearModels = (1 << 0),
	rsPrecompiledShaders = (1 << 1),
	rsGrassShadow = (1 << 2),
	rsNoScale = (1 << 3),
	rsFxaa = (1 << 4),
	rsDiscord = (1 << 5),
	rsKeypress = (1 << 6),
	rsCODPickup = (1 << 7),
	rsFeelGrenade = (1 << 8),
	rsOptShadowGeom = (1 << 9),
	rsAimSway = (1 << 10),
	rsAlwaysActive = (1 << 11),
};

class IRenderDevice
{
public:
	virtual CStatsPhysics* _BCL StatPhysics() = 0;
	virtual void _BCL AddSeqFrame(pureFrame* f, bool mt) = 0;
	virtual void _BCL RemoveSeqFrame(pureFrame* f) = 0;
};

class CRenderDeviceData
{
public:
	u32 dwWidth;
	u32 dwHeight;
	u32 dwPrecacheFrame;
	BOOL b_is_Ready;
	BOOL b_is_Active;
	BOOL b_hide_cursor;
	u32 dwFrame;
	float fTimeDelta;
	float fTimeGlobal;
	u32 dwTimeDelta;
	u32 dwTimeGlobal;
	u32 dwTimeContinual;
	Fvector vCameraPosition;
	Fvector vCameraDirection;
	Fvector vCameraTop;
	Fvector vCameraRight;
	Fmatrix mView;
	Fmatrix mProject;
	Fmatrix mFullTransform;
	Fvector vCameraPosition_saved;
	Fmatrix mView_saved;
	Fmatrix mProject_saved;
	Fmatrix mFullTransform_saved;
	float fFOV;
	float fASPECT;
	float ViewportNear = 0.2f;
  
  CRegistrator<pureRender> seqRender;
	CRegistrator<pureAppActivate> seqAppActivate;
	CRegistrator<pureAppDeactivate> seqAppDeactivate;
	CRegistrator<pureAppStart> seqAppStart;
	CRegistrator<pureAppEnd> seqAppEnd;
	CRegistrator<pureFrame> seqFrame;
	CRegistrator<pureScreenResolutionChanged> seqResolutionChanged;
	HWND m_hWnd;
  
protected:
	u32 Timer_MM_Delta;
	CTimer_paused Timer;
	CTimer_paused TimerGlobal;
	CTimer frame_timer;
};

class CRenderDeviceBase : public IRenderDevice, public CRenderDeviceData
{
};

class CSecondVPParams
{
public:
  bool isCamReady;

  bool IsSVPActive();
  void SetSVPActive(bool bState);
  bool IsSVPFrame();
  u8 GetSVPFrameDelay();
  void SetSVPFrameDelay(u8 iDelay);

private:
  bool isActive;
  u8 frameDelay;
};	

class CRenderDevice : public CRenderDeviceBase
{
public:  
	CRenderDevice()	:	m_pRender(0);
  LRESULT MsgProc(HWND, UINT, WPARAM, LPARAM);	
	void OnWM_Activate(WPARAM wParam, LPARAM lParam);
  void SetNearer(BOOL enabled);
	void DumpResourcesMemoryUsage();
	void Pause(BOOL bOn, BOOL bTimer, BOOL bSound, LPCSTR reason);
	bool Paused();
	void PreCache(u32 amount, bool b_draw_loadscreen, bool b_wait_user_input);
	BOOL Begin();
	void Clear();
	void End();
	void FrameMove();
	void overdrawBegin();
	void overdrawEnd();
	void Screenshot();
	void DumpFlags();
	IC CTimer_paused* GetTimerGlobal();
	u32 TimerAsync();
	u32 TimerAsync_MMT();
	void ConnectToRender();
	void Create(void);
	void Run(void);
	void Destroy(void);
	void Reset(bool precache = true);
	void Initialize(void);
	void ShutDown(void);
	void time_factor(const float& time_factor);
	const float& time_factor() const;
  void remove_from_seq_parallel(const fastdelegate::FastDelegate0<>& delegate);
	u32 frame_elapsed();
  void xr_stdcall on_idle();
	bool xr_stdcall on_message(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& result);

public:
	xrCriticalSection mt_csEnter;
	xrCriticalSection mt_csLeave;
	volatile BOOL mt_bMustExit;	
  CRegistrator<pureFrame> seqFrameMT;
	CRegistrator<pureDeviceReset> seqDeviceReset;
	xr_vector<fastdelegate::FastDelegate0<>> seqParallel;
	CStats* Statistic;
	Fmatrix mInvFullTransform;
	CSecondVPParams m_SecondViewport;
  u32 dwPrecacheTotal;
	float fWidth_2, fHeight_2;
  IRenderDeviceRender* m_pRender;
	BOOL m_bNearer;

private:
	void message_loop();
	virtual void _BCL AddSeqFrame(pureFrame* f, bool mt);
	virtual void _BCL RemoveSeqFrame(pureFrame* f);
	virtual CStatsPhysics* _BCL StatPhysics();
  void _Create(LPCSTR shName);
	void _Destroy(BOOL bKeepTextures);
	void _SetupStates();
  
private:
	u32 m_dwWindowStyle;
	RECT m_rcWindowBounds;
	RECT m_rcWindowClient;
	CTimer TimerMM; 
};

typedef fastdelegate::FastDelegate0<bool> LOADING_EVENT;

class CLoadScreenRenderer : public pureRender
{
public:
	CLoadScreenRenderer();
	void start(bool b_user_input);
	void stop();
	virtual void OnRender();

	bool b_registered;
	bool b_need_user_input;
};

static struct _DF
{
	char* name;
	u32 mask;
} DF[] =
{
	{"rsClearBB", rsClearBB},
	{"rsVSync", rsVSync},
	{"rsWireframe", rsWireframe},
	{NULL, 0}
};

class base
{
public:
	base();
	virtual ~base();
	void on_assign(base* const prev_action);
	virtual void on_key_press(line_edit_control* const control);

protected:
	base* m_previous_action;
};

class callback_base : public base
{
private:
	typedef fastdelegate::FastDelegate0<void> Callback;

public:
	callback_base(Callback const& callback, key_state state);
	virtual ~callback_base();
	virtual void on_key_press(line_edit_control* const control);

protected:
	key_state m_run_state;
	Callback m_callback;
};

class type_pair : public base
{
public:
	type_pair(u32 dik, char c, char c_shift, bool b_translate);
	virtual ~type_pair();
	void init(u32 dik, char c, char c_shift, bool b_translate);
	virtual void on_key_press(line_edit_control* const control);

private:
	u32 m_dik;
	bool m_translate;
	char m_char;
	char m_char_shift;
};

class key_state_base : public base
{
public:
	key_state_base(key_state state, base* type_pair);
	virtual ~key_state_base();
	virtual void on_key_press(line_edit_control* const control);

private:
	key_state m_state;
	base* m_type_pair;
};

class CEffectorCam : public SBaseEffector
{
public:
	CEffectorCam(ECamEffectorType type, float tm);
	CEffectorCam();
	virtual ~CEffectorCam();
	void SetType(ECamEffectorType type);
	void SetHudAffect(bool val);
	bool GetHudAffect();
	ECamEffectorType GetType();
	virtual BOOL Valid();
	virtual BOOL ProcessCam(SCamEffectorInfo& info);
	virtual void ProcessIfInvalid(SCamEffectorInfo& info);
	virtual BOOL AllowProcessingIfInvalid();
	virtual bool AbsolutePositioning();
  
protected:
	ECamEffectorType eType;
	friend class CCameraManager;
	float fLifeTime;
	bool bHudAffect;  
};

class CEffectorPP : public SBaseEffector
{  
public:
	CEffectorPP(EEffectorPPType type, f32 lifeTime, bool free_on_remove = true);
	CEffectorPP() : bFreeOnRemove(true), fLifeTime(0.0f), bOverlap(true);
	virtual ~CEffectorPP();
	virtual BOOL Process(SPPInfo& PPInfo);
	virtual BOOL Valid();
	EEffectorPPType Type() const;
	bool FreeOnRemove() const;
	void SetType(EEffectorPPType t);
	virtual void Stop(float speed);

public:
	bool bOverlap;
  
protected:
	float fLifeTime;
  
private:
	EEffectorPPType eType;
	bool bFreeOnRemove;
};

class CEngine
{  
public:
	CEngineAPI External;
	CEventAPI Event;
	CSheduler Sheduler;

	void Initialize();
	void Destroy();
	CEngine();
	~CEngine();
  
private:
	HMODULE hPSGP;
};

class DLL_Pure
{
public:
	CLASS_ID CLS_ID;

	DLL_Pure(void* params);
	DLL_Pure();
  
	virtual DLL_Pure* _construct();
	virtual ~DLL_Pure();
};

class CEngineAPI
{  
public:
	BENCH_SEC_SCRAMBLEMEMBER1
	Factory_Create* pCreate;
	Factory_Destroy* pDestroy;
	BOOL tune_enabled;
	VTPause* tune_pause;
	VTResume* tune_resume;
	void Initialize();
	void InitializeNotDedicated();
	void Destroy();
	void CreateRendererList();

	CEngineAPI();
	~CEngineAPI();
  
private:
	HMODULE hTuner;
};

struct SEnumVerticesCallback
{
	virtual void operator ()(const Fvector& p) = 0;
};

struct st_Key
{
  const u32 ktStepped = 1 << 0;
	float value;
	float time;
	u8 shape;
	float tension;
	float continuity;
	float bias;
	float param[4];

	st_Key();
	bool equal(const st_Key& tgt);
	void Save(IWriter& F);
	void Load_1(IReader& F);
	void Load_2(IReader& F);
};

class CEnvelope
{
public:
	KeyVec keys;
	int behavior[2];
  
public:
	CEnvelope();
	CEnvelope(CEnvelope* source);
	virtual ~CEnvelope();
	float Evaluate(float t);
	void Clear();
	void ClearAndFree();
	void Save(IWriter& F);
	void Load_1(IReader& F);
	void Load_2(IReader& F);
	void SaveA(IWriter& F);
	void LoadA(IReader& F);
	void RotateKeys(float angle);
	KeyIt FindKey(float t, float eps);
	void FindNearestKey(float t, KeyIt& min, KeyIt& max, float eps);
	void InsertKey(float t, float val);
	void DeleteKey(float t);
	BOOL ScaleKeys(float from_time, float to_time, float scale_factor, float eps);
	float GetLength(float* mn, float* mx);
	void Optimize();
};

class CEnvModifier
{
public:
	Fvector3 position;
	float radius;
	float power;
	float far_plane;
	Fvector3 fog_color;
	float fog_density;
	Fvector3 ambient;
	Fvector3 sky_color;
	Fvector3 hemi_color;
	Flags16 use_flags;

	void load(IReader* fs, u32 version);
	float sum(CEnvModifier& _another, Fvector3& view);
};

struct SSndChannel
{
public:
  shared_str m_load_section;
  Fvector2 m_sound_dist;
  Ivector4 m_sound_period;
  typedef xr_vector<ref_sound> sounds_type;

  void load(CInifile& config, LPCSTR sect);
  ref_sound& get_rnd_sound();
  u32 get_rnd_sound_time();
  u32 get_rnd_sound_first_time();
  float get_rnd_sound_dist();
  ~SSndChannel();
  inline sounds_type& sounds();

protected:
  xr_vector<ref_sound> m_sounds;
};

struct SEffect
{
  u32 life_time;
  ref_sound sound;
  shared_str particles;
  Fvector offset;
  float wind_gust_factor;
  float wind_blast_in_time;
  float wind_blast_out_time;
  float wind_blast_strength;
  Fvector wind_blast_direction;

  ~SEffect();
};

class CEnvAmbient
{
public:
	DEFINE_VECTOR(SEffect*, EffectVec, EffectVecIt);
	DEFINE_VECTOR(SSndChannel*, SSndChannelVec, SSndChannelVecIt);

public:
	const shared_str& name();
	const shared_str& get_ambients_config_filename();

	void load(CInifile& ambients_config, CInifile& sound_channels_config,	CInifile& effects_config,	const shared_str& section);
	IC SEffect* get_rnd_effect();
	IC u32 get_rnd_effect_time();

	SEffect* create_effect(CInifile& config, LPCSTR id);
	SSndChannel* create_sound_channel(CInifile& config, LPCSTR id);
	~CEnvAmbient();
  
	void destroy();
	inline EffectVec& effects();
	inline SSndChannelVec& get_snd_channels();
  
protected:
	shared_str m_load_section;
	EffectVec m_effects;
	Ivector2 m_effect_period;
	SSndChannelVec m_sound_channels;
	shared_str m_ambients_config_filename;
};

class CEnvDescriptor
{
public:
	float exec_time;
	float exec_time_loaded;
	shared_str sky_texture_name;
	shared_str sky_texture_env_name;
	shared_str clouds_texture_name;
	FactoryPtr<IEnvDescriptorRender> m_pDescriptor;
	Fvector4 clouds_color;
	Fvector3 sky_color;
	float sky_rotation;
	float far_plane;
	Fvector3 fog_color;
	float fog_density;
	float fog_distance;
	float rain_density;
	Fvector3 rain_color;
	float bolt_period;
	float bolt_duration;
	float wind_velocity;
	float wind_direction;
	float volumetric_intensity_factor;
	float volumetric_distance_factor;
	Fvector3 ambient;
	Fvector4 hemi_color;
	Fvector3 sun_color;
	Fvector3 sun_dir;
	float m_fSunShaftsIntensity;
	float m_fWaterIntensity;
	float m_fHemiVibrance;
	float m_fHemiContrast;
	float m_fWetSurfaces;
	float m_fTreeAmplitudeIntensity;
	shared_str lens_flare_id;
	shared_str tb_id;
	CEnvAmbient* env_ambient;
  shared_str m_identifier;

public:
	CEnvDescriptor(shared_str const& identifier);
	void load(CEnvironment& environment, CInifile& config);
	void copy(const CEnvDescriptor& src);
	void on_device_create();
	void on_device_destroy();	
};

class CEnvDescriptorMixer : public CEnvDescriptor
{
public:
	FactoryPtr<IEnvDescriptorMixerRender> m_pDescriptorMixer;
	float weight;
	float fog_near;
	float fog_far;
  
public:
	CEnvDescriptorMixer(shared_str const& identifier);
	INGAME_EDITOR_VIRTUAL void lerp(CEnvironment* parent, CEnvDescriptor& A, CEnvDescriptor& B, float f, CEnvModifier& M, float m_power);
	void boost(CEnvironment* env);
	void clear();
	void destroy();
};

struct str_pred : public std::binary_function<shared_str, shared_str, bool>
{
  bool operator()(const shared_str& x, const shared_str& y) const;
};

class CEnvironment
{
public:
	FactoryPtr<IEnvironmentRender> m_pRender;
	BOOL bNeed_re_create_env;
	float wind_strength_factor;
	float wind_gust_factor;
	float wetness_factor;
	Fvector4 wind_anim;
	float wind_blast_strength;
	Fvector wind_blast_direction;
	Fquaternion wind_blast_start_time;
	Fquaternion wind_blast_stop_time;
	float wind_blast_strength_start_value;
	float wind_blast_strength_stop_value;
	Fquaternion wind_blast_current;
	CEnvDescriptorMixer* CurrentEnv;
	CEnvDescriptor* Current[2];
	bool bWFX;
	float wfx_time;
	CEnvDescriptor* WFX_end_desc[2];
	EnvVec* CurrentWeather;
	shared_str CurrentWeatherName;
	shared_str CurrentCycleName;
	EnvsMap WeatherCycles;
	EnvsMap WeatherFXs;
	xr_vector<CEnvModifier> Modifiers;
	EnvAmbVec Ambients;
	CEffect_Rain* eff_Rain;
	CLensFlare* eff_LensFlare;
	CEffect_Thunderbolt* eff_Thunderbolt;
	float fTimeFactor;
  DEFINE_VECTOR(CEnvAmbient*, EnvAmbVec, EnvAmbVecIt);
	DEFINE_VECTOR(CEnvDescriptor*, EnvVec, EnvIt);
	DEFINE_MAP_PRED(shared_str, EnvVec, EnvsMap, EnvsMapIt, str_pred);
  CInifile* m_ambients_config;
	CInifile* m_sound_channels_config;
	CInifile* m_effects_config;
	CInifile* m_suns_config;
	CInifile* m_sun_pos_config;
	CInifile* m_thunderbolt_collections_config;
	CInifile* m_thunderbolts_config;
  float p_var_alt;
	float p_var_long;
	float p_min_dist;
	float p_tilt;
	float p_second_prop;
	float p_sky_color;
	float p_sun_color;
	float p_fog_color;
  
public:
	void SelectEnvs(float gt);
	void UpdateAmbient();
	CEnvAmbient* AppendEnvAmb(const shared_str& sect);
	void Invalidate();
	CEnvironment();
	~CEnvironment();
	void load();
	void unload();
	void Reload();
	void mods_load();
	void mods_unload();
	void OnFrame();
	void lerp(float& current_weight);
	void RenderSky();
	void RenderClouds();
	void RenderFlares();
	void RenderLast();
	bool SetWeatherFX(shared_str name);
	bool StartWeatherFXFromTime(shared_str name, float time);
	bool IsWFXPlaying();
	void StopWFX();
	void SetWeather(shared_str name, bool forced = false);
	shared_str GetWeather();
	void ChangeGameTime(float game_time);
	void SetGameTime(float game_time, float time_factor);
	void OnDeviceCreate();
	void OnDeviceDestroy();
  static bool sort_env_pred(const CEnvDescriptor* x, const CEnvDescriptor* y);
	static bool sort_env_etl_pred(const CEnvDescriptor* x, const CEnvDescriptor* y);
  SThunderboltDesc* thunderbolt_description(CInifile& config, shared_str const& section);
	SThunderboltCollection* thunderbolt_collection(CInifile* pIni, CInifile* thunderbolts, LPCSTR section);
	SThunderboltCollection* thunderbolt_collection(xr_vector<SThunderboltCollection*>& collection, shared_str const& id);
	CLensFlareDescriptor* add_flare(xr_vector<CLensFlareDescriptor*>& collection, shared_str const& id);	

protected:
	CEnvDescriptor* create_descriptor(shared_str const& identifier, CInifile* config);
	void load_sun();
	void load_weathers();
	void load_weather_effects();
	void create_mixer();
	void destroy_mixer();
	void load_level_specific_ambients();

protected:
	CPerlinNoise1D* PerlinNoise1D;
	float fGameTime;
  
private:
	friend class dxEnvironmentRender;	
  FvectorVec CloudsVerts;
	U16Vec CloudsIndices;

private:
	float NormalizeTime(float tm);
	float TimeDiff(float prev, float cur);
	float TimeWeight(float val, float min_t, float max_t);
	void SelectEnvs(EnvVec* envs, CEnvDescriptor*& e0, CEnvDescriptor*& e1, float tm);
	void SelectEnv(EnvVec* envs, CEnvDescriptor*& e, float tm);
	void calculate_dynamic_sun_dir();
	void calculate_config_sun_dir();
};

struct Slot 
{
  Token token;
  std::function<void(Args...)> fn;
};

template <typename... Args>
class Event final 
{
public:
    using Token = int;

    Event();
    Event(Event const&) = default;
    Event(Event&&) = default;
    ~Event() = default;
    Event& operator=(Event const&) = default;
    Event& operator=(Event&&) = default;

    template <typename EventHandler>
    Token Connect(EventHandler slot);
    void Disconnect(Token token);
    void DisconnectAll();
    void operator()(Args... args);

private:
    Token nextToken_{};
    std::vector<Slot> slots_{};
};

typedef CEvent* EVENT;

class IEventReceiver
{
public:
	virtual void OnEvent(EVENT E, u64 P1, u64 P2) = 0;
};

struct Deferred
{
  EVENT E;
  u64 P1;
  u64 P2;
};

class CEventAPI
{  
public:
	EVENT Create(const char* N);
	void Destroy(EVENT& E);
	EVENT Handler_Attach(const char* N, IEventReceiver* H);
	void Handler_Detach(EVENT& E, IEventReceiver* H);
	void Signal(EVENT E, u64 P1 = 0, u64 P2 = 0);
	void Signal(LPCSTR E, u64 P1 = 0, u64 P2 = 0);
	void Defer(EVENT E, u64 P1 = 0, u64 P2 = 0);
	void Defer(LPCSTR E, u64 P1 = 0, u64 P2 = 0);
	void OnFrame();
	void Dump();
	BOOL Peek(LPCSTR EName);
	void _destroy();
  
private:
	xr_vector<EVENT> Events;
	xr_vector<Deferred> Events_Deferred;
	xrCriticalSection CS;
};

class CDemoPlay : public CEffectorCam
{  
public:
	virtual BOOL ProcessCam(SCamEffectorInfo& info);
	CDemoPlay(const char* name, float ms, u32 cycles, float life_time = 60 * 60 * 1000);
	virtual ~CDemoPlay();
  
private:
	COMotion* m_pMotion;
	SAnimParams* m_MParam;
	xr_vector<Fmatrix> seq;
	int m_count;
	float fStartTime;
	float fSpeed;
	u32 dwCyclesLeft;
	BOOL stat_started;
	CTimer stat_Timer_frame;
	CTimer stat_Timer_total;
	u32 stat_StartFrame;
	xr_vector<float> stat_table;

private:
	void stat_Start();
	void stat_Stop();
};

struct force_position
{
  bool set_position;
  Fvector p;
}

struct force_direction
{
  bool set_direction;
  Fvector d;
}

class CDemoRecord : public CEffectorCam, public IInputReceiver,	public pureRender
{
public:
	CDemoRecord(const char* name, float life_time = 60 * 60 * 1000, BOOL return_ctrl_inputs = 0);
	CDemoRecord(const char* name, xr_unordered_set<CDemoRecord*>* pDemoRecords, BOOL isInputBlocked = 0, float life_time = 60 * 60 * 1000, BOOL return_ctrl_inputs = 0);
	virtual ~CDemoRecord();

	virtual void IR_OnKeyboardPress(int dik);
	virtual void IR_OnKeyboardRelease(int dik);
	virtual void IR_OnKeyboardHold(int dik);
	virtual void IR_OnMouseMove(int dx, int dy);
	virtual void IR_OnMouseHold(int btn);
	virtual void IR_OnMousePress(int btn);
	virtual void IR_OnMouseRelease(int btn);
	void StopDemo();
	void EnableReturnCtrlInputs();
	void SetCameraBoundary(float boundary);
	virtual BOOL ProcessCam(SCamEffectorInfo& info);
	static void SetGlobalPosition(const Fvector& p);
	static void GetGlobalPosition(Fvector& p);
	static void SetGlobalDirection(const Fvector& d);
	static void GetGlobalDirection(Fvector& d);
	BOOL m_b_redirect_input_to_level;
	virtual void OnRender();
  
private:
	force_position g_position;
  force_direction g_direction;
	int iCount;
	IWriter* file;
	Fvector m_HPB;
	Fvector m_Position;
	Fvector m_Actor_Position;
	Fvector m_Starting_Position;
	Fmatrix m_Camera;
	u32 m_Stage;
	Fvector m_vT;
	Fvector m_vR;
	Fvector m_vVelocity;
	Fvector m_vAngularVelocity;
	BOOL m_bMakeCubeMap;
	BOOL m_bMakeScreenshot;
	int m_iLMScreenshotFragment;
	BOOL m_bMakeLevelMap;
	BOOL return_ctrl_inputs;
	BOOL m_CameraBoundaryEnabled;
	float m_fSpeed0;
	float m_fSpeed1;
	float m_fSpeed2;
	float m_fSpeed3;
	float m_fAngSpeed0;
	float m_fAngSpeed1;
	float m_fAngSpeed2;
	float m_fAngSpeed3;
	float m_fCameraBoundary;
	float m_fGroundPosition;
	BOOL isInputBlocked;
	xr_unordered_set<CDemoRecord*>* pDemoRecords;

private:
	void MakeCubeMapFace(Fvector& D, Fvector& N);
	void MakeLevelMapProcess();
	void MakeScreenshotFace();
	void RecordKey();
	void MakeCubemap();
	void MakeScreenshot();
	void MakeLevelMapScreenshot(BOOL bHQ);
};

class Sound
{
public:
	virtual void feel_sound_new(CObject* who, int type, CSound_UserDataPtr user_data, const Fvector& Position, float power);
};

struct DenyTouch
{
  CObject* O;
  DWORD Expire;
};

class Touch : private pure_relcase
{
public:
	xr_vector<CObject*> feel_touch;
	xr_vector<CObject*> q_nearest;

public:
	void __stdcall feel_touch_relcase(CObject* O);
	Touch();
	virtual ~Touch();
	virtual bool feel_touch_contact(CObject* O);
	virtual void feel_touch_update(Fvector& P, float R);
	virtual void feel_touch_deny(CObject* O, DWORD T);
	virtual void feel_touch_new(CObject* O);
	virtual void feel_touch_delete(CObject* O);
  
protected:
	xr_vector<DenyTouch> feel_touch_disable;
};

struct feel_visible_Item
{
  collide::ray_cache Cache;
  Fvector cp_LP;
  Fvector cp_LR_src;
  Fvector cp_LR_dst;
  Fvector cp_LAST; // last point found to be visible
  CObject* O;
  float fuzzy; // note range: (-1[no]..1[yes])
  float Cache_vis;
  u16 bone_id;
};

class Vision : private pure_relcase
{  
public:
	Vision(CObject const* owner);
	virtual ~Vision();
	xr_vector<feel_visible_Item> feel_visible;
  
public:
	void feel_vision_clear();
	void feel_vision_query(Fmatrix& mFull, Fvector& P);
	void feel_vision_update(CObject* parent, Fvector& P, float dt, float vis_threshold);
	void __stdcall feel_vision_relcase(CObject* object);
	void feel_vision_get(xr_vector<CObject*>& R);
	Fvector feel_vision_get_vispoint(CObject* _O);
	virtual bool feel_vision_isRelevant(CObject* O) = 0;
	virtual float feel_vision_mtl_transp(CObject* O, u32 element) = 0;
  
private:
	xr_vector<CObject*> seen;
	xr_vector<CObject*> query;
	xr_vector<CObject*> diff;
	collide::rq_results RQR;
	xr_vector<ISpatial*> r_spatial;
	CObject const* m_owner;

private:
	void o_new(CObject* E);
	void o_delete(CObject* E);
	void o_trace(Fvector& P, float dt, float vis_threshold);
};

enum EDiscordResult 
{
    DiscordResult_Ok = 0,
    DiscordResult_ServiceUnavailable = 1,
    DiscordResult_InvalidVersion = 2,
    DiscordResult_LockFailed = 3,
    DiscordResult_InternalError = 4,
    DiscordResult_InvalidPayload = 5,
    DiscordResult_InvalidCommand = 6,
    DiscordResult_InvalidPermissions = 7,
    DiscordResult_NotFetched = 8,
    DiscordResult_NotFound = 9,
    DiscordResult_Conflict = 10,
    DiscordResult_InvalidSecret = 11,
    DiscordResult_InvalidJoinSecret = 12,
    DiscordResult_NoEligibleActivity = 13,
    DiscordResult_InvalidInvite = 14,
    DiscordResult_NotAuthenticated = 15,
    DiscordResult_InvalidAccessToken = 16,
    DiscordResult_ApplicationMismatch = 17,
    DiscordResult_InvalidDataUrl = 18,
    DiscordResult_InvalidBase64 = 19,
    DiscordResult_NotFiltered = 20,
    DiscordResult_LobbyFull = 21,
    DiscordResult_InvalidLobbySecret = 22,
    DiscordResult_InvalidFilename = 23,
    DiscordResult_InvalidFileSize = 24,
    DiscordResult_InvalidEntitlement = 25,
    DiscordResult_NotInstalled = 26,
    DiscordResult_NotRunning = 27,
    DiscordResult_InsufficientBuffer = 28,
    DiscordResult_PurchaseCanceled = 29,
    DiscordResult_InvalidGuild = 30,
    DiscordResult_InvalidEvent = 31,
    DiscordResult_InvalidChannel = 32,
    DiscordResult_InvalidOrigin = 33,
    DiscordResult_RateLimited = 34,
    DiscordResult_OAuth2Error = 35,
    DiscordResult_SelectChannelTimeout = 36,
    DiscordResult_GetGuildTimeout = 37,
    DiscordResult_SelectVoiceForceRequired = 38,
    DiscordResult_CaptureShortcutAlreadyListening = 39,
    DiscordResult_UnauthorizedForAchievement = 40,
    DiscordResult_InvalidGiftCode = 41,
    DiscordResult_PurchaseError = 42,
    DiscordResult_TransactionAborted = 43,
    DiscordResult_DrawingInitFailed = 44,
};

enum EDiscordCreateFlags 
{
    DiscordCreateFlags_Default = 0,
    DiscordCreateFlags_NoRequireDiscord = 1,
};

enum EDiscordLogLevel 
{
    DiscordLogLevel_Error = 1,
    DiscordLogLevel_Warn,
    DiscordLogLevel_Info,
    DiscordLogLevel_Debug,
};

enum EDiscordUserFlag 
{
    DiscordUserFlag_Partner = 2,
    DiscordUserFlag_HypeSquadEvents = 4,
    DiscordUserFlag_HypeSquadHouse1 = 64,
    DiscordUserFlag_HypeSquadHouse2 = 128,
    DiscordUserFlag_HypeSquadHouse3 = 256,
};

enum EDiscordPremiumType 
{
    DiscordPremiumType_None = 0,
    DiscordPremiumType_Tier1 = 1,
    DiscordPremiumType_Tier2 = 2,
};

enum EDiscordImageType 
{
    DiscordImageType_User,
};

enum EDiscordActivityType 
{
    DiscordActivityType_Playing,
    DiscordActivityType_Streaming,
    DiscordActivityType_Listening,
    DiscordActivityType_Watching,
};

enum EDiscordActivityActionType 
{
    DiscordActivityActionType_Join = 1,
    DiscordActivityActionType_Spectate,
};

enum EDiscordActivityJoinRequestReply 
{
    DiscordActivityJoinRequestReply_No,
    DiscordActivityJoinRequestReply_Yes,
    DiscordActivityJoinRequestReply_Ignore,
};

enum EDiscordStatus 
{
    DiscordStatus_Offline = 0,
    DiscordStatus_Online = 1,
    DiscordStatus_Idle = 2,
    DiscordStatus_DoNotDisturb = 3,
};

enum EDiscordRelationshipType 
{
    DiscordRelationshipType_None,
    DiscordRelationshipType_Friend,
    DiscordRelationshipType_Blocked,
    DiscordRelationshipType_PendingIncoming,
    DiscordRelationshipType_PendingOutgoing,
    DiscordRelationshipType_Implicit,
};

enum EDiscordLobbyType 
{
    DiscordLobbyType_Private = 1,
    DiscordLobbyType_Public,
};

enum EDiscordLobbySearchComparison 
{
    DiscordLobbySearchComparison_LessThanOrEqual = -2,
    DiscordLobbySearchComparison_LessThan,
    DiscordLobbySearchComparison_Equal,
    DiscordLobbySearchComparison_GreaterThan,
    DiscordLobbySearchComparison_GreaterThanOrEqual,
    DiscordLobbySearchComparison_NotEqual,
};

enum EDiscordLobbySearchCast 
{
    DiscordLobbySearchCast_String = 1,
    DiscordLobbySearchCast_Number,
};

enum EDiscordLobbySearchDistance 
{
    DiscordLobbySearchDistance_Local,
    DiscordLobbySearchDistance_Default,
    DiscordLobbySearchDistance_Extended,
    DiscordLobbySearchDistance_Global,
};

enum EDiscordKeyVariant 
{
    DiscordKeyVariant_Normal,
    DiscordKeyVariant_Right,
    DiscordKeyVariant_Left,
};

enum EDiscordMouseButton 
{
    DiscordMouseButton_Left,
    DiscordMouseButton_Middle,
    DiscordMouseButton_Right,
};

enum EDiscordEntitlementType 
{
    DiscordEntitlementType_Purchase = 1,
    DiscordEntitlementType_PremiumSubscription,
    DiscordEntitlementType_DeveloperGift,
    DiscordEntitlementType_TestModePurchase,
    DiscordEntitlementType_FreePurchase,
    DiscordEntitlementType_UserGift,
    DiscordEntitlementType_PremiumPurchase,
};

enum EDiscordSkuType 
{
    DiscordSkuType_Application = 1,
    DiscordSkuType_DLC,
    DiscordSkuType_Consumable,
    DiscordSkuType_Bundle,
};

enum EDiscordInputModeType 
{
    DiscordInputModeType_VoiceActivity = 0,
    DiscordInputModeType_PushToTalk,
};

typedef int64_t DiscordClientId;
typedef int32_t DiscordVersion;
typedef int64_t DiscordSnowflake;
typedef int64_t DiscordTimestamp;
typedef DiscordSnowflake DiscordUserId;
typedef char DiscordLocale[128];
typedef char DiscordBranch[4096];
typedef DiscordSnowflake DiscordLobbyId;
typedef char DiscordLobbySecret[128];
typedef char DiscordMetadataKey[256];
typedef char DiscordMetadataValue[4096];
typedef uint64_t DiscordNetworkPeerId;
typedef uint8_t DiscordNetworkChannelId;
typedef char DiscordPath[4096];
typedef char DiscordDateTime[64];

struct DiscordUser {
    DiscordUserId id;
    char username[256];
    char discriminator[8];
    char avatar[128];
    bool bot;
};

struct DiscordOAuth2Token {
    char access_token[128];
    char scopes[1024];
    DiscordTimestamp expires;
};

struct DiscordImageHandle {
    enum EDiscordImageType type;
    int64_t id;
    uint32_t size;
};

struct DiscordImageDimensions {
    uint32_t width;
    uint32_t height;
};

struct DiscordActivityTimestamps {
    DiscordTimestamp start;
    DiscordTimestamp end;
};

struct DiscordActivityAssets {
    char large_image[128];
    char large_text[128];
    char small_image[128];
    char small_text[128];
};

struct DiscordPartySize {
    int32_t current_size;
    int32_t max_size;
};

struct DiscordActivityParty {
    char id[128];
    struct DiscordPartySize size;
};

struct DiscordActivitySecrets {
    char match[128];
    char join[128];
    char spectate[128];
};

struct DiscordActivity {
    enum EDiscordActivityType type;
    int64_t application_id;
    char name[128];
    char state[128];
    char details[128];
    struct DiscordActivityTimestamps timestamps;
    struct DiscordActivityAssets assets;
    struct DiscordActivityParty party;
    struct DiscordActivitySecrets secrets;
    bool instance;
};

struct DiscordPresence {
    enum EDiscordStatus status;
    struct DiscordActivity activity;
};

struct DiscordRelationship {
    enum EDiscordRelationshipType type;
    struct DiscordUser user;
    struct DiscordPresence presence;
};

struct DiscordLobby {
    DiscordLobbyId id;
    enum EDiscordLobbyType type;
    DiscordUserId owner_id;
    DiscordLobbySecret secret;
    uint32_t capacity;
    bool locked;
};

struct DiscordImeUnderline {
    int32_t from;
    int32_t to;
    uint32_t color;
    uint32_t background_color;
    bool thick;
};

struct DiscordRect {
    int32_t left;
    int32_t top;
    int32_t right;
    int32_t bottom;
};

struct DiscordFileStat {
    char filename[260];
    uint64_t size;
    uint64_t last_modified;
};

struct DiscordEntitlement {
    DiscordSnowflake id;
    enum EDiscordEntitlementType type;
    DiscordSnowflake sku_id;
};

struct DiscordSkuPrice {
    uint32_t amount;
    char currency[16];
};

struct DiscordSku {
    DiscordSnowflake id;
    enum EDiscordSkuType type;
    char name[256];
    struct DiscordSkuPrice price;
};

struct DiscordInputMode {
    enum EDiscordInputModeType type;
    char shortcut[256];
};

struct DiscordUserAchievement {
    DiscordSnowflake user_id;
    DiscordSnowflake achievement_id;
    uint8_t percent_complete;
    DiscordDateTime unlocked_at;
};

struct IDiscordLobbyTransaction 
{
    enum EDiscordResult (*set_type)(struct IDiscordLobbyTransaction* lobby_transaction,
                                    enum EDiscordLobbyType type);
    enum EDiscordResult (*set_owner)(struct IDiscordLobbyTransaction* lobby_transaction,
                                     DiscordUserId owner_id);
    enum EDiscordResult (*set_capacity)(struct IDiscordLobbyTransaction* lobby_transaction,
                                        uint32_t capacity);
    enum EDiscordResult (*set_metadata)(struct IDiscordLobbyTransaction* lobby_transaction,
                                        DiscordMetadataKey key,
                                        DiscordMetadataValue value);
    enum EDiscordResult (*delete_metadata)(struct IDiscordLobbyTransaction* lobby_transaction,
                                           DiscordMetadataKey key);
    enum EDiscordResult (*set_locked)(struct IDiscordLobbyTransaction* lobby_transaction,
                                      bool locked);
};

struct IDiscordLobbyMemberTransaction 
{
    EDiscordResult (*set_metadata)(IDiscordLobbyMemberTransaction* lobby_member_transaction, DiscordMetadataKey key, DiscordMetadataValue value);
    EDiscordResult (*delete_metadata)(IDiscordLobbyMemberTransaction* lobby_member_transaction, DiscordMetadataKey key);
};

struct IDiscordLobbySearchQuery 
{
    EDiscordResult (*filter)(IDiscordLobbySearchQuery* lobby_search_query, DiscordMetadataKey key, EDiscordLobbySearchComparison comparison, EDiscordLobbySearchCast cast, DiscordMetadataValue value);
    EDiscordResult (*sort)(IDiscordLobbySearchQuery* lobby_search_query, DiscordMetadataKey key, EDiscordLobbySearchCast cast, DiscordMetadataValue value);
    EDiscordResult (*limit)(IDiscordLobbySearchQuery* lobby_search_query, uint32_t limit);
    EDiscordResult (*distance)(struct IDiscordLobbySearchQuery* lobby_search_query, EDiscordLobbySearchDistance distance);
};

typedef void* IDiscordApplicationEvents;

struct IDiscordApplicationManager 
{
    void (*validate_or_exit)(IDiscordApplicationManager* manager, void* callback_data, void (*callback)(void* callback_data, EDiscordResult result));
    void (*get_current_locale)(IDiscordApplicationManager* manager, DiscordLocale* locale);
    void (*get_current_branch)(IDiscordApplicationManager* manager, DiscordBranch* branch);
    void (*get_oauth2_token)(IDiscordApplicationManager* manager, void* callback_data, void (*callback)(void* callback_data, EDiscordResult result, DiscordOAuth2Token* oauth2_token));
    void (*get_ticket)(struct IDiscordApplicationManager* manager, void* callback_data, void (*callback)(void* callback_data, EDiscordResult result, const char* data));
};

struct IDiscordUserEvents 
{
    void (*on_current_user_update)(void* event_data);
};

struct IDiscordUserManager 
{
    EDiscordResult (*get_current_user)(IDiscordUserManager* manager, DiscordUser* current_user);
    void (*get_user)(IDiscordUserManager* manager, DiscordUserId user_id, void* callback_data, void (*callback)(void* callback_data, EDiscordResult result, DiscordUser* user));
    EDiscordResult (*get_current_user_premium_type)(IDiscordUserManager* manager, EDiscordPremiumType* premium_type);
    EDiscordResult (*current_user_has_flag)(struct IDiscordUserManager* manager, EDiscordUserFlag flag, bool* has_flag);
};

typedef void* IDiscordImageEvents;

struct IDiscordImageManager 
{
    void (*fetch)(IDiscordImageManager* manager, DiscordImageHandle handle, bool refresh, void* callback_data, void (*callback)(void* callback_data, EDiscordResult result, DiscordImageHandle handle_result));
    EDiscordResult (*get_dimensions)(IDiscordImageManager* manager, DiscordImageHandle handle, DiscordImageDimensions* dimensions);
    EDiscordResult (*get_data)(IDiscordImageManager* manager, DiscordImageHandle handle, uint8_t* data, uint32_t data_length);
};

struct IDiscordActivityEvents 
{
    void (*on_activity_join)(void* event_data, const char* secret);
    void (*on_activity_spectate)(void* event_data, const char* secret);
    void (*on_activity_join_request)(void* event_data, DiscordUser* user);
    void (*on_activity_invite)(void* event_data, EDiscordActivityActionType type, DiscordUser* user, DiscordActivity* activity);
};

struct IDiscordActivityManager 
{
    EDiscordResult (*register_command)(IDiscordActivityManager* manager, const char* command);
    EDiscordResult (*register_steam)(IDiscordActivityManager* manager, uint32_t steam_id);
    void (*update_activity)(IDiscordActivityManager* manager, DiscordActivity* activity, void* callback_data, void (*callback)(void* callback_data, enum EDiscordResult result));
    void (*clear_activity)(IDiscordActivityManager* manager, void* callback_data, void (*callback)(void* callback_data, enum EDiscordResult result));
    void (*send_request_reply)(IDiscordActivityManager* manager, DiscordUserId user_id, EDiscordActivityJoinRequestReply reply, void* callback_data, void (*callback)(void* callback_data, EDiscordResult result));
    void (*send_invite)(IDiscordActivityManager* manager, DiscordUserId user_id, EDiscordActivityActionType type, const char* content, void* callback_data, void (*callback)(void* callback_data, EDiscordResult result));
    void (*accept_invite)(IDiscordActivityManager* manager, DiscordUserId user_id, void* callback_data, void (*callback)(void* callback_data, EDiscordResult result));
};

struct IDiscordRelationshipEvents 
{
    void (*on_refresh)(void* event_data);
    void (*on_relationship_update)(void* event_data, DiscordRelationship* relationship);
};

struct IDiscordRelationshipManager 
{
    void (*filter)(IDiscordRelationshipManager* manager, void* filter_data, bool (*filter)(void* filter_data, DiscordRelationship* relationship));
    EDiscordResult (*count)(IDiscordRelationshipManager* manager, int32_t* count);
    EDiscordResult (*get)(IDiscordRelationshipManager* manager, DiscordUserId user_id, DiscordRelationship* relationship);
    EDiscordResult (*get_at)(IDiscordRelationshipManager* manager, uint32_t index, DiscordRelationship* relationship);
};

struct IDiscordLobbyEvents 
{
    void (*on_lobby_update)(void* event_data, int64_t lobby_id);
    void (*on_lobby_delete)(void* event_data, int64_t lobby_id, uint32_t reason);
    void (*on_member_connect)(void* event_data, int64_t lobby_id, int64_t user_id);
    void (*on_member_update)(void* event_data, int64_t lobby_id, int64_t user_id);
    void (*on_member_disconnect)(void* event_data, int64_t lobby_id, int64_t user_id);
    void (*on_lobby_message)(void* event_data, int64_t lobby_id, int64_t user_id, uint8_t* data, uint32_t data_length);
    void (*on_speaking)(void* event_data, int64_t lobby_id, int64_t user_id, bool speaking);
    void (*on_network_message)(void* event_data, int64_t lobby_id, int64_t user_id, uint8_t channel_id, uint8_t* data, uint32_t data_length);
};

struct IDiscordLobbyManager 
{
    EDiscordResult (*get_lobby_create_transaction)(IDiscordLobbyManager* manager, IDiscordLobbyTransaction** transaction);
    EDiscordResult (*get_lobby_update_transaction)(IDiscordLobbyManager* manager, DiscordLobbyId lobby_id, IDiscordLobbyTransaction** transaction);
    EDiscordResult (*get_member_update_transaction)(IDiscordLobbyManager* manager, DiscordLobbyId lobby_id, DiscordUserId user_id, IDiscordLobbyMemberTransaction** transaction);
    void (*create_lobby)(IDiscordLobbyManager* manager, IDiscordLobbyTransaction* transaction, void* callback_data, void (*callback)(void* callback_data, EDiscordResult result, DiscordLobby* lobby));
    void (*update_lobby)(IDiscordLobbyManager* manager, DiscordLobbyId lobby_id, IDiscordLobbyTransaction* transaction, void* callback_data, void (*callback)(void* callback_data, EDiscordResult result));
    void (*delete_lobby)(IDiscordLobbyManager* manager, DiscordLobbyId lobby_id, void* callback_data, void (*callback)(void* callback_data, EDiscordResult result));
    void (*connect_lobby)(IDiscordLobbyManager* manager, DiscordLobbyId lobby_id, DiscordLobbySecret secret, void* callback_data, void (*callback)(void* callback_data, EDiscordResult result, DiscordLobby* lobby));
    void (*connect_lobby_with_activity_secret)(IDiscordLobbyManager* manager, DiscordLobbySecret activity_secret, void* callback_data, void (*callback)(void* callback_data, EDiscordResult result, DiscordLobby* lobby));
    void (*disconnect_lobby)(IDiscordLobbyManager* manager, DiscordLobbyId lobby_id, void* callback_data, void (*callback)(void* callback_data, EDiscordResult result));
    EDiscordResult (*get_lobby)(struct IDiscordLobbyManager* manager, DiscordLobbyId lobby_id, DiscordLobby* lobby);
    EDiscordResult (*get_lobby_activity_secret)(struct IDiscordLobbyManager* manager, DiscordLobbyId lobby_id, DiscordLobbySecret* secret);
    EDiscordResult (*get_lobby_metadata_value)(struct IDiscordLobbyManager* manager, DiscordLobbyId lobby_id, DiscordMetadataKey key, DiscordMetadataValue* value);
    EDiscordResult (*get_lobby_metadata_key)(IDiscordLobbyManager* manager, DiscordLobbyId lobby_id, int32_t index, DiscordMetadataKey* key);
    EDiscordResult (*lobby_metadata_count)(IDiscordLobbyManager* manager, DiscordLobbyId lobby_id, int32_t* count);
    EDiscordResult (*member_count)(IDiscordLobbyManager* manager, DiscordLobbyId lobby_id, int32_t* count);
    EDiscordResult (*get_member_user_id)(IDiscordLobbyManager* manager, DiscordLobbyId lobby_id, int32_t index, DiscordUserId* user_id);
    EDiscordResult (*get_member_user)(IDiscordLobbyManager* manager, DiscordLobbyId lobby_id, DiscordUserId user_id, DiscordUser* user);
    EDiscordResult (*get_member_metadata_value)(IDiscordLobbyManager* manager, DiscordLobbyId lobby_id, DiscordUserId user_id, DiscordMetadataKey key, DiscordMetadataValue* value);
    EDiscordResult (*get_member_metadata_key)(IDiscordLobbyManager* manager, DiscordLobbyId lobby_id, DiscordUserId user_id, int32_t index, DiscordMetadataKey* key);
    EDiscordResult (*member_metadata_count)(IDiscordLobbyManager* manager, DiscordLobbyId lobby_id, DiscordUserId user_id, int32_t* count);
    void (*update_member)(IDiscordLobbyManager* manager, DiscordLobbyId lobby_id, DiscordUserId user_id, IDiscordLobbyMemberTransaction* transaction, void* callback_data, void (*callback)(void* callback_data, EDiscordResult result));
    void (*send_lobby_message)(IDiscordLobbyManager* manager, DiscordLobbyId lobby_id, uint8_t* data, uint32_t data_length, void* callback_data, void (*callback)(void* callback_data, EDiscordResult result));
    EDiscordResult (*get_search_query)(IDiscordLobbyManager* manager, IDiscordLobbySearchQuery** query);
    void (*search)(IDiscordLobbyManager* manager, IDiscordLobbySearchQuery* query, void* callback_data, void (*callback)(void* callback_data, EDiscordResult result));
    void (*lobby_count)(struct IDiscordLobbyManager* manager, int32_t* count);
    EDiscordResult (*get_lobby_id)(IDiscordLobbyManager* manager, int32_t index, DiscordLobbyId* lobby_id);
    void (*connect_voice)(IDiscordLobbyManager* manager, DiscordLobbyId lobby_id, void* callback_data, void (*callback)(void* callback_data, EDiscordResult result));
    void (*disconnect_voice)(struct IDiscordLobbyManager* manager, DiscordLobbyId lobby_id, void* callback_data, void (*callback)(void* callback_data, EDiscordResult result));
    EDiscordResult (*connect_network)(IDiscordLobbyManager* manager, DiscordLobbyId lobby_id);
    EDiscordResult (*disconnect_network)(IDiscordLobbyManager* manager, DiscordLobbyId lobby_id);
    EDiscordResult (*flush_network)(IDiscordLobbyManager* manager);
    EDiscordResult (*open_network_channel)(IDiscordLobbyManager* manager, DiscordLobbyId lobby_id, uint8_t channel_id, bool reliable);
    EDiscordResult (*send_network_message)(IDiscordLobbyManager* manager, DiscordLobbyId lobby_id, DiscordUserId user_id, uint8_t channel_id, uint8_t* data, uint32_t data_length);
};

struct IDiscordNetworkEvents 
{
    void (*on_message)(void* event_data, DiscordNetworkPeerId peer_id, DiscordNetworkChannelId channel_id, uint8_t* data, uint32_t data_length);
    void (*on_route_update)(void* event_data, const char* route_data);
};

struct IDiscordNetworkManager 
{
    void (*get_peer_id)(IDiscordNetworkManager* manager, DiscordNetworkPeerId* peer_id);
    EDiscordResult (*flush)(IDiscordNetworkManager* manager);
    EDiscordResult (*open_peer)(IDiscordNetworkManager* manager, DiscordNetworkPeerId peer_id, const char* route_data);
    EDiscordResult (*update_peer)(IDiscordNetworkManager* manager, DiscordNetworkPeerId peer_id, const char* route_data);
    EDiscordResult (*close_peer)(IDiscordNetworkManager* manager, DiscordNetworkPeerId peer_id);
    EDiscordResult (*open_channel)(IDiscordNetworkManager* manager, DiscordNetworkPeerId peer_id, DiscordNetworkChannelId channel_id, bool reliable);
    EDiscordResult (*close_channel)(IDiscordNetworkManager* manager, DiscordNetworkPeerId peer_id, DiscordNetworkChannelId channel_id);
    EDiscordResult (*send_message)(IDiscordNetworkManager* manager, DiscordNetworkPeerId peer_id, DiscordNetworkChannelId channel_id, uint8_t* data, uint32_t data_length);
};

struct IDiscordOverlayEvents 
{
    void (*on_toggle)(void* event_data, bool locked);
};

struct IDiscordOverlayManager 
{
    void (*is_enabled)(IDiscordOverlayManager* manager, bool* enabled);
    void (*is_locked)(IDiscordOverlayManager* manager, bool* locked);
    void (*set_locked)(IDiscordOverlayManager* manager, bool locked, void* callback_data, void (*callback)(void* callback_data, EDiscordResult result));
    void (*open_activity_invite)(IDiscordOverlayManager* manager, EDiscordActivityActionType type, void* callback_data, void (*callback)(void* callback_data, EDiscordResult result));
    void (*open_guild_invite)(IDiscordOverlayManager* manager, const char* code, void* callback_data, void (*callback)(void* callback_data, EDiscordResult result));
    void (*open_voice_settings)(IDiscordOverlayManager* manager, void* callback_data, void (*callback)(void* callback_data, EDiscordResult result));
    EDiscordResult (*init_drawing_dxgi)(IDiscordOverlayManager* manager, IDXGISwapChain* swapchain, bool use_message_forwarding);
    void (*on_present)(IDiscordOverlayManager* manager);
    void (*forward_message)(IDiscordOverlayManager* manager, MSG* message);
    void (*key_event)(IDiscordOverlayManager* manager, bool down, const char* key_code, EDiscordKeyVariant variant);
    void (*char_event)(IDiscordOverlayManager* manager, const char* character);
    void (*mouse_button_event)(IDiscordOverlayManager* manager, uint8_t down, int32_t click_count, EDiscordMouseButton which, int32_t x, int32_t y);
    void (*mouse_motion_event)(IDiscordOverlayManager* manager, int32_t x, int32_t y);
    void (*ime_commit_text)(IDiscordOverlayManager* manager, const char* text);
    void (*ime_set_composition)(IDiscordOverlayManager* manager, const char* text, struct DiscordImeUnderline* underlines, uint32_t underlines_length, int32_t from, int32_t to);
    void (*ime_cancel_composition)(IDiscordOverlayManager* manager);
    void (*set_ime_composition_range_callback)(IDiscordOverlayManager* manager, void* on_ime_composition_range_changed_data, void (*on_ime_composition_range_changed)(void* on_ime_composition_range_changed_data, int32_t from, int32_t to, struct DiscordRect* bounds, uint32_t bounds_length));
    void (*set_ime_selection_bounds_callback)(DiscordOverlayManager* manager, void* on_ime_selection_bounds_changed_data, void (*on_ime_selection_bounds_changed)(void* on_ime_selection_bounds_changed_data, struct DiscordRect anchor, struct DiscordRect focus, bool is_anchor_first));
    bool (*is_point_inside_click_zone)(IDiscordOverlayManager* manager, int32_t x, int32_t y);
};

typedef void* IDiscordStorageEvents;

struct IDiscordStorageManager 
{
    EDiscordResult (*read)(IDiscordStorageManager* manager, const char* name, uint8_t* data, uint32_t data_length, uint32_t* read);
    void (*read_async)(IDiscordStorageManager* manager, const char* name, void* callback_data, void (*callback)(void* callback_data, EDiscordResult result, uint8_t* data, uint32_t data_length));
    void (*read_async_partial)(IDiscordStorageManager* manager, const char* name, uint64_t offset, uint64_t length, void* callback_data, void (*callback)(void* callback_data, EDiscordResult result, uint8_t* data, uint32_t data_length));
    EDiscordResult (*write)(IDiscordStorageManager* manager, const char* name, uint8_t* data, uint32_t data_length);
    void (*write_async)(IDiscordStorageManager* manager, const char* name, uint8_t* data, uint32_t data_length, void* callback_data, void (*callback)(void* callback_data, EDiscordResult result));
    EDiscordResult (*delete_)(IDiscordStorageManager* manager, const char* name);
    EDiscordResult (*exists)(IDiscordStorageManager* manager, const char* name, bool* exists);
    void (*count)(struct IDiscordStorageManager* manager, int32_t* count);
    EDiscordResult (*stat)(IDiscordStorageManager* manager, const char* name, DiscordFileStat* stat);
    EDiscordResult (*stat_at)(IDiscordStorageManager* manager, int32_t index, DiscordFileStat* stat);
    EDiscordResult (*get_path)(IDiscordStorageManager* manager, DiscordPath* path);
};

struct IDiscordStoreEvents 
{
    void (*on_entitlement_create)(void* event_data, DiscordEntitlement* entitlement);
    void (*on_entitlement_delete)(void* event_data, DiscordEntitlement* entitlement);
};

struct IDiscordStoreManager 
{
    void (*fetch_skus)(IDiscordStoreManager* manager, void* callback_data, void (*callback)(void* callback_data, EDiscordResult result));
    void (*count_skus)(IDiscordStoreManager* manager, int32_t* count);
    EDiscordResult (*get_sku)(IDiscordStoreManager* manager, DiscordSnowflake sku_id, DiscordSku* sku);
    EDiscordResult (*get_sku_at)(IDiscordStoreManager* manager, int32_t index, DiscordSku* sku);
    void (*fetch_entitlements)(IDiscordStoreManager* manager, void* callback_data, void (*callback)(void* callback_data, EDiscordResult result));
    void (*count_entitlements)(IDiscordStoreManager* manager, int32_t* count);
    EDiscordResult (*get_entitlement)(IDiscordStoreManager* manager, DiscordSnowflake entitlement_id, DiscordEntitlement* entitlement);
    EDiscordResult (*get_entitlement_at)(IDiscordStoreManager* manager, int32_t index, DiscordEntitlement* entitlement);
    EDiscordResult (*has_sku_entitlement)(IDiscordStoreManager* manager, DiscordSnowflake sku_id, bool* has_entitlement);
    void (*start_purchase)(IDiscordStoreManager* manager, DiscordSnowflake sku_id, void* callback_data, void (*callback)(void* callback_data, EDiscordResult result));
};

struct IDiscordVoiceEvents 
{
    void (*on_settings_update)(void* event_data);
};

struct IDiscordVoiceManager 
{
    EDiscordResult (*get_input_mode)(IDiscordVoiceManager* manager, DiscordInputMode* input_mode);
    void (*set_input_mode)(IDiscordVoiceManager* manager, DiscordInputMode input_mode, void* callback_data, void (*callback)(void* callback_data, EDiscordResult result));
    EDiscordResult (*is_self_mute)(IDiscordVoiceManager* manager, bool* mute);
    EDiscordResult (*set_self_mute)(IDiscordVoiceManager* manager, bool mute);
    EDiscordResult (*is_self_deaf)(IDiscordVoiceManager* manager, bool* deaf);
    EDiscordResult (*set_self_deaf)(IDiscordVoiceManager* manager, bool deaf);
    EDiscordResult (*is_local_mute)(IDiscordVoiceManager* manager, DiscordSnowflake user_id, bool* mute);
    EDiscordResult (*set_local_mute)(IDiscordVoiceManager* manager, DiscordSnowflake user_id, bool mute);
    EDiscordResult (*get_local_volume)(IDiscordVoiceManager* manager, DiscordSnowflake user_id, uint8_t* volume);
    EDiscordResult (*set_local_volume)(IDiscordVoiceManager* manager, DiscordSnowflake user_id, uint8_t volume);
};

struct IDiscordAchievementEvents 
{
    void (*on_user_achievement_update)(void* event_data, DiscordUserAchievement* user_achievement);
};

struct IDiscordAchievementManager 
{
    void (*set_user_achievement)(IDiscordAchievementManager* manager, DiscordSnowflake achievement_id, uint8_t percent_complete, void* callback_data, void (*callback)(void* callback_data, EDiscordResult result));
    void (*fetch_user_achievements)(IDiscordAchievementManager* manager, void* callback_data, void (*callback)(void* callback_data, EDiscordResult result));
    void (*count_user_achievements)(struct IDiscordAchievementManager* manager, int32_t* count);
    EDiscordResult (*get_user_achievement)(struct IDiscordAchievementManager* manager, DiscordSnowflake user_achievement_id, DiscordUserAchievement* user_achievement);
    EDiscordResult (*get_user_achievement_at)(IDiscordAchievementManager* manager, int32_t index, DiscordUserAchievement* user_achievement);
};

typedef void* IDiscordCoreEvents;

struct IDiscordCore 
{
    void (*destroy)(IDiscordCore* core);
    EDiscordResult (*run_callbacks)(IDiscordCore* core);
    void (*set_log_hook)(IDiscordCore* core, EDiscordLogLevel min_level, void* hook_data, void (*hook)(void* hook_data, EDiscordLogLevel level, const char* message));
    IDiscordApplicationManager* (*get_application_manager)(IDiscordCore* core);
    IDiscordUserManager* (*get_user_manager)(IDiscordCore* core);
    IDiscordImageManager* (*get_image_manager)(IDiscordCore* core);
    IDiscordActivityManager* (*get_activity_manager)(IDiscordCore* core);
    IDiscordRelationshipManager* (*get_relationship_manager)(IDiscordCore* core);
    IDiscordLobbyManager* (*get_lobby_manager)(IDiscordCore* core);
    IDiscordNetworkManager* (*get_network_manager)(IDiscordCore* core);
    IDiscordOverlayManager* (*get_overlay_manager)(IDiscordCore* core);
    IDiscordStorageManager* (*get_storage_manager)(IDiscordCore* core);
    IDiscordStoreManager* (*get_store_manager)(IDiscordCore* core);
    IDiscordVoiceManager* (*get_voice_manager)(IDiscordCore* core);
    IDiscordAchievementManager* (*get_achievement_manager)(IDiscordCore* core);
};

struct DiscordCreateParams 
{
    DiscordClientId client_id;
    uint64_t flags;
    IDiscordCoreEvents* events;
    void* event_data;
    IDiscordApplicationEvents* application_events;
    DiscordVersion application_version;
    struct IDiscordUserEvents* user_events;
    DiscordVersion user_version;
    IDiscordImageEvents* image_events;
    DiscordVersion image_version;
    struct IDiscordActivityEvents* activity_events;
    DiscordVersion activity_version;
    struct IDiscordRelationshipEvents* relationship_events;
    DiscordVersion relationship_version;
    struct IDiscordLobbyEvents* lobby_events;
    DiscordVersion lobby_version;
    struct IDiscordNetworkEvents* network_events;
    DiscordVersion network_version;
    struct IDiscordOverlayEvents* overlay_events;
    DiscordVersion overlay_version;
    IDiscordStorageEvents* storage_events;
    DiscordVersion storage_version;
    struct IDiscordStoreEvents* store_events;
    DiscordVersion store_version;
    struct IDiscordVoiceEvents* voice_events;
    DiscordVersion voice_version;
    struct IDiscordAchievementEvents* achievement_events;
    DiscordVersion achievement_version;
};

enum MT
{
	MT_NORMAL = 0,
	MT_HIERRARHY = 1,
	MT_PROGRESSIVE = 2,
	MT_SKELETON_ANIM = 3,
	MT_SKELETON_GEOMDEF_PM = 4,
	MT_SKELETON_GEOMDEF_ST = 5,
	MT_LOD = 6,
	MT_TREE_ST = 7,
	MT_PARTICLE_EFFECT = 8,
	MT_PARTICLE_GROUP = 9,
	MT_SKELETON_RIGID = 10,
	MT_TREE_PM = 11,

	MT_3DFLUIDVOLUME = 12,
};

enum OGF_Chuncks
{
	OGF_HEADER = 1,
	OGF_TEXTURE = 2,
	OGF_VERTICES = 3,
	OGF_INDICES = 4,
	OGF_P_MAP = 5,
	OGF_SWIDATA = 6,
	OGF_VCONTAINER = 7,
	// not used ??
	OGF_ICONTAINER = 8,
	// not used ??
	OGF_CHILDREN = 9,
	// * For skeletons only
	OGF_CHILDREN_L = 10,
	// Link to child visuals
	OGF_LODDEF2 = 11,
	// + 5 channel data
	OGF_TREEDEF2 = 12,
	// + 5 channel data
	OGF_S_BONE_NAMES = 13,
	// * For skeletons only
	OGF_S_MOTIONS = 14,
	OGF_S_SMPARAMS = 15,
	OGF_S_IKDATA = 16,
	OGF_S_USERDATA = 17,
	OGF_S_DESC = 18,
	OGF_S_MOTION_REFS = 19,
	OGF_SWICONTAINER = 20,
	// * SlidingWindowItem record container
	OGF_GCONTAINER = 21,
	// * both VB&IB
	OGF_FASTPATH = 22,
	// * extended/fast geometry
	OGF_S_LODS = 23,
	OGF_S_MOTION_REFS2 = 24,
	// * changes in format
	OGF_COLLISION_VERTICES = 25,
	OGF_COLLISION_INDICES = 26,
	OGF_forcedword = 0xFFFFFFFF
};

enum OGF_SkeletonVertType
{
	OGF_VERTEXFORMAT_FVF_1L = 1 * 0x12071980,
	OGF_VERTEXFORMAT_FVF_2L = 2 * 0x12071980,
	OGF_VERTEXFORMAT_FVF_3L = 4 * 0x12071980,
	OGF_VERTEXFORMAT_FVF_4L = 5 * 0x12071980,
	OGF_VERTEXFORMAT_FVF_NL = 3 * 0x12071980,
};

struct ogf_desc
{
	shared_str source_file;
	shared_str build_name;
	time_t build_time;
	shared_str create_name;
	time_t create_time;
	shared_str modif_name;
	time_t modif_time;

	ogf_desc() : build_time(0), create_time(0), modif_time(0);
	void Load(IReader& F);
	void Save(IWriter& F);
};

struct ogf_bbox
{
	Fvector min;
	Fvector max;
};

struct ogf_bsphere
{
	Fvector c;
	float r;
};

struct ogf_header
{
	u8 format_version; // = xrOGF_FormatVersion
	u8 type; // MT
	u16 shader_id; // should not be ZERO
	ogf_bbox bb;
	ogf_bsphere bs;
};

struct FSlideWindow
{
	u32 offset;
	u16 num_tris;
	u16 num_verts;
};

struct FSlideWindowItem
{
	FSlideWindow* sw;
	u32 count;
	u32 reserved[4];

	FSlideWindowItem() : sw(0), count(0);
};

enum
{
  fsGradient = (1 << 0),
  fsDeviceIndependent = (1 << 1),
  fsValid = (1 << 2),
  fsMultibyte = (1 << 3),
  fsForceDWORD = u32(-1)
};

enum EAligment
{
  alLeft = 0,
  alRight,
  alCenter
};

struct String
{
  string1024 string;
  float x, y;
  float height;
  u32 c;
  EAligment align;
};

class CGameFont
{
public:
	CGameFont(LPCSTR section, u32 flags = 0);
	CGameFont(LPCSTR shader, LPCSTR texture, u32 flags = 0);
	~CGameFont();
	void Initialize(LPCSTR shader, LPCSTR texture);
	void SetColor(u32 C);
	void SetHeightI(float S);
	void SetHeight(float S);
	float GetHeight();
	void SetInterval(float x, float y);
	void SetInterval(const Fvector2& v);
	void SetAligment(EAligment aligment);
	float SizeOf_(LPCSTR s);
	float SizeOf_(const wide_char* wsStr);
	float SizeOf_(const char cChar);
	float CurrentHeight_();
	void OutSetI(float x, float y);
	void OutSet(float x, float y);
	void MasterOut(BOOL bCheckDevice, BOOL bUseCoords, BOOL bScaleCoords, BOOL bUseSkip, float _x, float _y, float _skip, LPCSTR fmt, va_list p);
	u32 smart_strlen(const char* S);
	BOOL IsMultibyte() { return (uFlags & fsMultibyte); };
	u16 SplitByWidth(u16* puBuffer, u16 uBufferSize, float fTargetWidth, const char* pszText);
	u16 GetCutLengthPos(float fTargetWidth, const char* pszText);
	void OutI(float _x, float _y, LPCSTR fmt, ...);
	void Out(float _x, float _y, LPCSTR fmt, ...);
	void OutNext(LPCSTR fmt, ...);
	void OutSkip(float val = 1.f);
	void OnRender();
	void Clear();

public:
  shared_str m_font_name;

protected:
	Fvector2 vHalfPixel;
	Ivector2 vTS;
	EAligment eCurrentAlignment;
	u32 dwCurrentColor;
	float fCurrentHeight;
	float fCurrentX, fCurrentY;
	Fvector2 vInterval;
	Fvector* TCMap;
	float fHeight;
	float fXStep;
	float fYStep;
	float fTCHeight;
	xr_vector<String> strings;
	IFontRender* pFontRender;
	u32 nNumChars;
	u32 uFlags;

protected:
	const Fvector& GetCharTC(u16 c);
  
private:
	friend class dxFontRender;
};

enum
{
	flBreakable = (1ul << 0ul),
	flBounceable = (1ul << 2ul),
	flSkidmark = (1ul << 3ul),
	flBloodmark = (1ul << 4ul),
	flClimable = (1ul << 5ul),
	flPassable = (1ul << 7ul),
	flDynamic = (1ul << 8ul),
	flLiquid = (1ul << 9ul),
	flSuppressShadows = (1ul << 10ul),
	flSuppressWallmarks = (1ul << 11ul),
	flActorObstacle = (1ul << 12ul),
	flNoRicoshet = (1ul << 13ul),
	flInjurious = (1ul << 28ul),
	flShootable = (1ul << 29ul),
	flTransparent = (1ul << 30ul),
	flSlowDown = (1ul << 31ul)
};

struct SGameMtl
{
public:
	shared_str m_Name;
	shared_str m_Desc;
	Flags32 Flags;
	float fPHFriction; // ?
	float fPHDamping; // ?
	float fPHSpring; // ?
	float fPHBounceStartVelocity; // ?
	float fPHBouncing; // ?
	float fFlotationFactor; // 0.f - 1.f (1.f-полностью проходимый)
	float fShootFactor; // 0.f - 1.f (1.f-полностью простреливаемый)
	float fShootFactorMP; // 0.f - 1.f (1.f-полностью простреливаемый)
	float fBounceDamageFactor; // 0.f - 100.f
	float fInjuriousSpeed; // 0.f - ... (0.f-не отбирает здоровье (скорость уменьшения здоровья))
	float fVisTransparencyFactor; // 0.f - 1.f (1.f-полностью прозрачный)
	float fSndOcclusionFactor; // 0.f - 1.f (1.f-полностью слышен)
	float fDensityFactor;
  
public:
	SGameMtl();
	void Load(IReader& fs);
	void Save(IWriter& fs);
	int GetID();
  
private:
	friend class CGameMtlLibrary;
  
protected:
	int ID; // auto number
};

enum
{
  flBreakingSounds = (1 << 1),
  flStepSounds = (1 << 2),
  flCollideSounds = (1 << 4),
  flCollideParticles = (1 << 5),
  flCollideMarks = (1 << 6)
};

struct SGameMtlPair
{  
public:
	xr_string BreakingSoundsStr;
	xr_string StepSoundsStr;
	xr_string CollideSoundsStr;
	xr_string CollideParticlesStr;
	xr_string CollideMarksStr;
	Flags32 OwnProps;
	SoundVec BreakingSounds;
	SoundVec StepSounds;
	SoundVec CollideSounds;
	PSVec CollideParticles;
	FactoryPtr<IWallMarkArray> m_pCollideMarks;

public:
	SGameMtlPair(CGameMtlLibrary* owner);  
	~SGameMtlPair();
  void CreateSoundsImpl(SoundVec& sounds, LPCSTR str);
	void CreateParticlesImpl(PSVec& particles, LPCSTR str);
	void CreateMarksImpl(IWallMarkArray* marks, LPCSTR str);
	int GetMtl0();
	int GetMtl1();
	int GetID();
	void SetPair(int m0, int m1);
	bool IsPair(int m0, int m1);
	void Save(IWriter& fs);
	void Load(IReader& fs);
	int GetParent();
	BOOL SetParent(int parent);
  LPCSTR dbg_Name();
  
private:
  friend class CGameMtlLibrary;
	CGameMtlLibrary* m_Owner;
	int mtl0;
	int mtl1;
  
protected:
	int ID; // auto number
	int ID_parent;
};

DEFINE_VECTOR(SGameMtlPair*, GameMtlPairVec, GameMtlPairIt);

class CGameMtlLibrary
{
public:
	CGameMtlLibrary();
	~CGameMtlLibrary();
	IC void Unload();
	GameMtlIt GetMaterialIt(LPCSTR name);
	GameMtlIt GetMaterialIt(shared_str& name);
	GameMtlIt GetMaterialItByID(int id);
	u32 GetMaterialID(LPCSTR name);
	SGameMtl* GetMaterialByID(s32 id);
	u16 GetMaterialIdx(int ID);
	u16 GetMaterialIdx(LPCSTR name);
	SGameMtl* GetMaterialByIdx(u16 idx);
	GameMtlIt FirstMaterial();
	GameMtlIt LastMaterial();
	u32 CountMaterial();
	SGameMtlPair* GetMaterialPair(u16 idx0, u16 idx1);
	GameMtlPairIt FirstMaterialPair();
	GameMtlPairIt LastMaterialPair();
	void Load();
	bool Save();
  
private:
	int material_index;
	int material_pair_index;
	GameMtlVec materials;
	GameMtlPairVec material_pairs;
};

class ICollidable
{
public:
	ICollisionForm* model;

	ICollidable();
	virtual ~ICollidable();
};

struct SItem_ServerInfo
{
  string128 name;
  u32 color;
};

class CServerInfo
{
public:
	u32 Size();
	void ResetData();
	void AddItem(LPCSTR name_, LPCSTR value_, u32 color_ = RGB(255, 255, 255));
	void AddItem(shared_str& name_, LPCSTR value_, u32 color_ = RGB(255, 255, 255));
	SItem_ServerInfo& operator[](u32 id);
	CServerInfo();
	~CServerInfo();
  
private:
	const u32 max_item = 15;
	svector<SItem_ServerInfo, max_item> data;
};

struct _esound_delegate
{
  Feel::Sound* dest;
  ref_sound_data_ptr source;
  float power;
};

class IGame_Level :	public DLL_Pure, public IInputReceiver, public pureRender, public pureFrame, public IEventReceiver
{  
public:
	CObjectList Objects;
	CObjectSpace ObjectSpace;
	CCameraManager& Cameras();
	BOOL bReady;
	CInifile* pLevel;
	xr_vector<_esound_delegate> snd_Events;
  
public:
	IGame_Level();
	virtual ~IGame_Level();
	virtual shared_str name() const = 0;
	virtual void GetLevelInfo(CServerInfo* si) = 0;
	virtual bool net_Start(const char* op_server, const char* op_client) = 0;
	virtual void net_Load(const char* name) = 0;
	virtual void net_Save(const char* name) = 0;
	virtual void net_Stop();
	virtual void net_Update() = 0;
	virtual bool Load(u32 dwNum);
	virtual bool Load_GameSpecific_Before();
	virtual bool Load_GameSpecific_After();
	virtual void Load_GameSpecific_CFORM(CDB::TRI* T, u32 count) = 0;
	virtual void _BCL OnFrame(void);
	virtual void OnRender(void);
	virtual shared_str OpenDemoFile(const char* demo_file_name) = 0;
	virtual void net_StartPlayDemo() = 0;
	CObject* CurrentEntity(void) const;
	CObject* CurrentViewEntity(void) const;
	void SetEntity(CObject* O);
	void SetViewEntity(CObject* O);
	void SoundEvent_Register(ref_sound_data_ptr S, float range);
	void SoundEvent_Dispatch();
	void SoundEvent_OnDestDestroy(Feel::Sound*);
	void LL_CheckTextures();
	virtual void SetEnvironmentGameTimeFactor(u64 const& GameTime, float const& fTimeFactor) = 0;
  
protected:
	CObject* pCurrentEntity;
	CObject* pCurrentViewEntity;
	xr_vector<ref_sound> Sounds_Random;
	u32 Sounds_Random_dwNextTime;
	BOOL Sounds_Random_Enabled;
	CCameraManager* m_pCameras;
	xr_vector<ISpatial*> snd_ER;
};

class IGame_ObjectPool
{  
public:
	void prefetch();
	void clear();
	CObject* create(LPCSTR name);
	void destroy(CObject* O);
	IGame_ObjectPool();
	virtual ~IGame_ObjectPool();
  
private:
	typedef xr_vector<CObject*> ObjectVec;
	typedef ObjectVec::iterator ObjectVecIt;
	ObjectVec m_PrefetchObjects;
};

struct grass_data
{
  u8 index;
  s8 anim[16];
  u16 id[16];
  Fvector pos[16];
  Fvector3 dir[16];
  float radius[16];
  float radius_curr[16];
  float str[16];
  float str_target[16];
  float time[16];
  float fade[16];
  float speed[16];
}

enum GrassBenders_Anim
{
  BENDER_ANIM_EXPLOSION = 0,
  BENDER_ANIM_DEFAULT = 1,
  BENDER_ANIM_WAVY = 2,
  BENDER_ANIM_SUCK = 3,
  BENDER_ANIM_BLOW = 4,
  BENDER_ANIM_PULSE = 5,
}; 

struct act_dat
{
  float health;
  float stamina;
  float bleeding;
  BOOL helmet;
}

struct pda_data
{
  float pda_display_factor;
  float pda_psy_influence;
  float pda_displaybrightness;
}

struct nv_data
{
  float lum_factor;
}

class IGame_Persistent : public DLL_Pure, public pureAppStart, public pureAppEnd, public pureAppActivate, public pureAppDeactivate, public pureFrame
{
public:
	union params
	{
		struct
		{
			string256 m_game_or_spawn;
			string256 m_game_type;
			string256 m_alife;
			string256 m_new_or_load;
			EGameIDs m_e_game_type;
		};

		string256 m_params[4];
		params();
		void reset();
		void parse_cmd_line(LPCSTR cmd_line);
	};
	params m_game_params;
	xr_set<CPS_Instance*> ps_active;
	xr_vector<CPS_Instance*> ps_destroy;
	xr_vector<CPS_Instance*> ps_needtoplay;
  CPerlinNoise1D* PerlinNoise1D;
  grass_data grass_shader_data;
  IMainMenu* m_pMainMenu;
	ScriptWallmarksManager* m_pWallmarksManager;
  ShadersExternalData* m_pGShaderConstants;
  IGame_ObjectPool ObjectPool;
	CEnvironment* pEnvironment;
  act_dat actor_data;
  pda_data pda_shader_data;
  nv_data nv_shader_data;
  
public:
	void GrassBendersUpdateAnimations();
	void GrassBendersAddExplosion(u16 id, Fvector position, Fvector3 dir, float fade, float speed, float intensity, float radius);
	void GrassBendersAddShot(u16 id, Fvector position, Fvector3 dir, float fade, float speed, float intensity, float radius);
	void GrassBendersRemoveById(u16 id);
	void GrassBendersRemoveByIndex(u8& idx);
	void GrassBendersUpdate(u16 id, u8& data_idx, u32& data_frame, Fvector& position, float radius, float str, bool CheckDistance );
	void GrassBendersReset(u8 idx);
	void GrassBendersSet(u8 idx, u16 id, Fvector position, Fvector3 dir, float fade, float speed, float str, float radius, GrassBenders_Anim anim, bool resetTime);
	float GrassBenderToValue(float& current, float go_to, float intensity, bool use_easing);
  void destroy_particles(const bool& all_particles);
	virtual void PreStart(LPCSTR op);
	virtual void Start(LPCSTR op);
	virtual void Disconnect();	
	CEnvironment& Environment();
	void Prefetch();	
	ScriptWallmarksManager& GetWallmarksManager() const;
	virtual bool OnRenderPPUI_query();
	virtual void OnRenderPPUI_main();
	virtual void OnRenderPPUI_PP();
	virtual void OnAppStart();
	virtual void OnAppEnd();
	virtual void OnAppActivate();
	virtual void OnAppDeactivate();
	virtual void _BCL OnFrame();
	virtual void OnGameStart();
	virtual void OnGameEnd();
	virtual void UpdateGameType();
	virtual void GetCurrentDof(Fvector3& dof);
	virtual void SetBaseDof(const Fvector3& dof);
	virtual void OnSectorChanged(int sector);
	virtual void OnAssetsChanged();
	virtual void RegisterModel(IRenderVisual* V)= 0;
	virtual float MtlTransparent(u32 mtl_idx)	= 0;
	IGame_Persistent();
	virtual ~IGame_Persistent();
	ICF u32 GameType();
	virtual void Statistics(CGameFont* F)	= 0;
	virtual void LoadTitle(bool change_tip = false, shared_str map_name = "");
	virtual bool CanBePaused();

private:
	CInifile* m_textures_prefetch_config;  
};

class IMainMenu
{
public:
	virtual ~IMainMenu();
	virtual void Activate(bool bActive) = 0;
	virtual bool IsActive() = 0;
	virtual bool CanSkipSceneRendering() = 0;
	virtual void DestroyInternal(bool bForce) = 0;
};

class IInputReceiver
{
public:
	static void IR_GetLastMouseDelta(Ivector2& p);
	static void IR_GetMousePosScreen(Ivector2& p);
	static void IR_GetMousePosReal(HWND hwnd, Ivector2& p);
	static void IR_GetMousePosReal(Ivector2& p);
	static void IR_GetMousePosIndependent(Fvector2& f);
	static void IR_GetMousePosIndependentCrop(Fvector2& f);
	BOOL IR_GetKeyState(int dik);
	BOOL IR_GetBtnState(int btn);
	void IR_Capture(void);
	void IR_Release(void);
	virtual void IR_OnDeactivate(void);
	virtual void IR_OnActivate(void);
	virtual void IR_OnMousePress(int btn);
	virtual void IR_OnMouseRelease(int btn);
	virtual void IR_OnMouseHold(int btn);
	virtual void IR_OnMouseWheel(int direction);
	virtual void IR_OnMouseMove(int x, int y);
	virtual void IR_OnMouseStop(int x, int y);
	virtual void IR_OnKeyboardPress(int dik);
	virtual void IR_OnKeyboardRelease(int dik);
	virtual void IR_OnKeyboardHold(int dik);
};

class ImageManager final 
{
public:
    ~ImageManager() = default;

    void Fetch(ImageHandle handle, bool refresh, std::function<void(Result, ImageHandle)> callback);
    Result GetDimensions(ImageHandle handle, ImageDimensions* dimensions);
    Result GetData(ImageHandle handle, std::uint8_t* data, std::uint32_t dataLength);

private:
    friend class Core;

    ImageManager() = default;
    ImageManager(ImageManager const& rhs) = delete;
    ImageManager& operator=(ImageManager const& rhs) = delete;
    ImageManager(ImageManager&& rhs) = delete;
    ImageManager& operator=(ImageManager&& rhs) = delete;

    IDiscordImageManager* internal_;
    static IDiscordImageEvents events_;
};

__interface IObjectPhysicsCollision
{
public:
	virtual const IPhysicsShell* physics_shell() const = 0;
	virtual const IPhysicsElement* physics_character() const = 0; //depricated
};

__interface IPhDebugRender
{
	virtual void open_cashed_draw() = 0;
	virtual void close_cashed_draw(u32 remove_time) = 0;
	virtual void draw_tri(const Fvector& v0, const Fvector& v1, const Fvector& v2, u32 c, bool solid) = 0;
};

class IPhysicsGeometry
{
public:
	virtual void get_Box(Fmatrix& form, Fvector& sz) const = 0;
	virtual bool collide_fluids() const = 0;
};

class IPhysicsElement
{
public:
	virtual const Fmatrix& XFORM() const = 0;
	virtual void get_LinearVel(Fvector& velocity) const = 0;
	virtual void get_AngularVel(Fvector& velocity) const = 0;
	virtual void get_Box(Fvector& sz, Fvector& c) const = 0;
	virtual const Fvector& mass_Center() const = 0;
	virtual u16 numberOfGeoms() const = 0;
	virtual const IPhysicsGeometry* geometry(u16 i) const = 0;
};

class IPhysicsShell
{
public:
	virtual const Fmatrix& XFORM() const = 0;
	virtual const IPhysicsElement& Element(u16 index) const = 0;
	virtual u16 get_ElementsNumber() const = 0;
};

class IRenderable
{
public:
	Fmatrix xform;
  IRenderVisual* visual;
  IRender_ObjectSpecific* pROS;
  BOOL pROS_Allowed;

public:
	IRenderable();
	virtual ~IRenderable();
	IRender_ObjectSpecific* renderable_ROS();
	virtual void renderable_Render() = 0;
	virtual BOOL renderable_ShadowGenerate();
	virtual BOOL renderable_ShadowReceive();
	virtual float GetHotness();
	virtual float GetTransparency();
	virtual float GetGlowing();
};

class ISheduled
{
public:
	u32 t_min : 14; // minimal bound of update time (sample: 20ms)
  u32 t_max : 14; // maximal bound of update time (sample: 200ms)
  u32 b_RT : 1;
  u32 b_locked : 1;
  u32 dbg_startframe;
  u32 dbg_update_shedule;

	ISheduled();
	virtual ~ISheduled();
	void shedule_register();
	void shedule_unregister();
	virtual float shedule_Scale() = 0;
	virtual void shedule_Update(u32 dt);
	virtual shared_str shedule_Name() const;
	virtual bool shedule_Needed() = 0;
};

class CLAItem
{
public:
	shared_str cName;
	float fFPS;
	float def_fFPS;
	DEFINE_MAP(int, u32, KeyMap, KeyPairIt);
	KeyMap Keys;
	int iFrameCount;
  
public:
	CLAItem();
	void InitDefault();
	void Load(IReader& F);
	void Save(IWriter& F);
	float Length_sec();
	u32 Length_ms();
	u32 InterpolateRGB(int frame);
	u32 InterpolateBGR(int frame);
	u32 CalculateRGB(float T, int& frame);
	u32 CalculateBGR(float T, int& frame);
	void SetFramerate(float framerate);
	void ResetFramerate();
	void Resize(int new_len);
	void InsertKey(int frame, u32 color);
	void DeleteKey(int frame);
	void MoveKey(int from, int to);
	bool IsKey(int frame);
	int PrevKeyFrame(int frame);
	int NextKeyFrame(int frame);
	int FirstKeyFrame();
	int LastKeyFrame();
	u32* GetKey(int frame);
};

DEFINE_VECTOR(CLAItem*, LAItemVec, LAItemIt);

class ELightAnimLibrary
{
public:
	LAItemVec Items;
	LAItemIt FindItemI(LPCSTR name);
	CLAItem* FindItem(LPCSTR name);
	ELightAnimLibrary();
	~ELightAnimLibrary();
	void OnCreate();
	void OnDestroy();
	void Load();
	void Save();
	void Reload();
	void Unload();
	CLAItem* AppendItem(LPCSTR name, CLAItem* src);
	LAItemVec& Objects();
};

enum key_state
{
	ks_free = u32(0),
	ks_LShift = u32(1) << 0,
	ks_RShift = u32(1) << 1,
	ks_LCtrl = u32(1) << 2,
	ks_RCtrl = u32(1) << 3,
	ks_LAlt = u32(1) << 4,
	ks_RAlt = u32(1) << 5,
	ks_CapsLock = u32(1) << 6,
	ks_Shift = u32(ks_LShift | ks_RShift),
	ks_Ctrl = u32(ks_LCtrl | ks_RCtrl),
	ks_Alt = u32(ks_LAlt | ks_RAlt),
	ks_force = u32(-1)
};

enum init_mode
{
	im_standart = 0,
	im_number_only,
	im_read_only,
	im_file_name_mode,
	im_count
};

enum 
{ 
  MIN_BUF_SIZE = 8, 
  MAX_BUF_SIZE = 4096 
};

class line_edit_control
{
public:
	line_edit_control(u32 str_buffer_size);
	void init(u32 str_buffer_size, init_mode mode = im_standart);
	~line_edit_control();
	void clear_states();
	void on_key_press(int dik);
	void on_key_hold(int dik);
	void on_key_release(int dik);
	void on_frame();
	void assign_callback(u32 const dik, key_state state, Callback const& callback);
	void insert_character(char c);
	IC bool get_key_state(key_state mask) const;
	IC void set_key_state(key_state mask, bool value);
	IC bool cursor_view() const;
	IC bool need_update() const;
	IC LPCSTR str_edit() const;
	IC LPCSTR str_before_cursor() const;
	IC LPCSTR str_before_mark() const;
	IC LPCSTR str_mark() const;
	IC LPCSTR str_after_mark() const;
	void set_edit(LPCSTR str);
	void set_selected_mode(bool status);
	bool get_selected_mode() const;

private:
	line_edit_control(line_edit_control const&);
	line_edit_control const& operator=(line_edit_control const&);
	void update_key_states();
	void update_bufs();
	void xr_stdcall undo_buf();
	void xr_stdcall select_all_buf();
	void xr_stdcall flip_insert_mode();
	void xr_stdcall copy_to_clipboard();
	void xr_stdcall paste_from_clipboard();
	void xr_stdcall cut_to_clipboard();
	void xr_stdcall move_pos_home();
	void xr_stdcall move_pos_end();
	void xr_stdcall move_pos_left();
	void xr_stdcall move_pos_right();
	void xr_stdcall move_pos_left_word();
	void xr_stdcall move_pos_right_word();
	void xr_stdcall delete_selected_back();
	void xr_stdcall delete_selected_forward();
	void xr_stdcall delete_word_back();
	void xr_stdcall delete_word_forward();
	void xr_stdcall SwitchKL();
	void assign_char_pairs(init_mode mode);
	void create_key_state(u32 const dik, key_state state);
	void create_char_pair(u32 const dik, char c, char c_shift, bool translate = false);
	void clear_inserted();
	bool empty_inserted();
	void add_inserted_text();
	void delete_selected(bool back);
	void compute_positions();
	void clamp_cur_pos();

private:
  typedef text_editor::base Base;
	typedef fastdelegate::FastDelegate0<void> Callback;

	const u32 DIK_COUNT = 256;
	Base* m_actions[DIK_COUNT];
	char* m_edit_str;
	char* m_undo_buf;
	char* m_inserted;
	char* m_buf0;
	char* m_buf1;
	char* m_buf2;
	char* m_buf3;
	int m_buffer_size;
	int m_cur_pos;
	int m_select_start;
	int m_p1;
	int m_p2;
	float m_accel;
	float m_cur_time;
	float m_rep_time;
	float m_last_key_time;
	u32 m_last_frame_time;
	u32 m_last_changed_frame;
	Flags32 m_key_state;
	bool m_hold_mode;
	bool m_insert_mode;
	bool m_repeat_mode;
	bool m_mark;
	bool m_cursor_view;
	bool m_need_update;
	bool m_unselected_mode;
};

class line_editor : public IInputReceiver
{
public:
	line_editor(u32 str_buffer_size);
	virtual ~line_editor();
	line_edit_control& control();
	void on_frame();

protected:
	virtual void IR_OnKeyboardPress(int dik);
	virtual void IR_OnKeyboardHold(int dik);
	virtual void IR_OnKeyboardRelease(int dik);

private:
	line_edit_control m_control;
};

class LobbyEvents final 
{
public:
    static void OnLobbyUpdate(void* callbackData, int64_t lobbyId);
    static void OnLobbyDelete(void* callbackData, int64_t lobbyId, uint32_t reason);
    static void OnMemberConnect(void* callbackData, int64_t lobbyId, int64_t userId);
    static void OnMemberUpdate(void* callbackData, int64_t lobbyId, int64_t userId);
    static void OnMemberDisconnect(void* callbackData, int64_t lobbyId, int64_t userId);
    static void OnLobbyMessage(void* callbackData, int64_t lobbyId, int64_t userId, uint8_t* data, uint32_t dataLength);
    static void OnSpeaking(void* callbackData, int64_t lobbyId, int64_t userId, bool speaking);
    static void OnNetworkMessage(void* callbackData, int64_t lobbyId, int64_t userId, uint8_t channelId, uint8_t* data, uint32_t dataLength);
};

class LobbyManager final 
{
public:
    ~LobbyManager() = default;
    Result GetLobbyCreateTransaction(LobbyTransaction* transaction);
    Result GetLobbyUpdateTransaction(LobbyId lobbyId, LobbyTransaction* transaction);
    Result GetMemberUpdateTransaction(LobbyId lobbyId, UserId userId, LobbyMemberTransaction* transaction);
    void CreateLobby(LobbyTransaction const& transaction, std::function<void(Result, Lobby const&)> callback);
    void UpdateLobby(LobbyId lobbyId, LobbyTransaction const& transaction, std::function<void(Result)> callback);
    void DeleteLobby(LobbyId lobbyId, std::function<void(Result)> callback);
    void ConnectLobby(LobbyId lobbyId, LobbySecret secret, std::function<void(Result, Lobby const&)> callback);
    void ConnectLobbyWithActivitySecret(LobbySecret activitySecret, std::function<void(Result, Lobby const&)> callback);
    void DisconnectLobby(LobbyId lobbyId, std::function<void(Result)> callback);
    Result GetLobby(LobbyId lobbyId, Lobby* lobby);
    Result GetLobbyActivitySecret(LobbyId lobbyId, char secret[128]);
    Result GetLobbyMetadataValue(LobbyId lobbyId, MetadataKey key, char value[4096]);
    Result GetLobbyMetadataKey(LobbyId lobbyId, std::int32_t index, char key[256]);
    Result LobbyMetadataCount(LobbyId lobbyId, std::int32_t* count);
    Result MemberCount(LobbyId lobbyId, std::int32_t* count);
    Result GetMemberUserId(LobbyId lobbyId, std::int32_t index, UserId* userId);
    Result GetMemberUser(LobbyId lobbyId, UserId userId, User* user);
    Result GetMemberMetadataValue(LobbyId lobbyId, UserId userId, MetadataKey key, char value[4096]);
    Result GetMemberMetadataKey(LobbyId lobbyId, UserId userId, std::int32_t index, char key[256]);
    Result MemberMetadataCount(LobbyId lobbyId, UserId userId, std::int32_t* count);
    void UpdateMember(LobbyId lobbyId, UserId userId, LobbyMemberTransaction const& transaction, std::function<void(Result)> callback);
    void SendLobbyMessage(LobbyId lobbyId, std::uint8_t* data, std::uint32_t dataLength, std::function<void(Result)> callback);
    Result GetSearchQuery(LobbySearchQuery* query);
    void Search(LobbySearchQuery const& query, std::function<void(Result)> callback);
    void LobbyCount(std::int32_t* count);
    Result GetLobbyId(std::int32_t index, LobbyId* lobbyId);
    void ConnectVoice(LobbyId lobbyId, std::function<void(Result)> callback);
    void DisconnectVoice(LobbyId lobbyId, std::function<void(Result)> callback);
    Result ConnectNetwork(LobbyId lobbyId);
    Result DisconnectNetwork(LobbyId lobbyId);
    Result FlushNetwork();
    Result OpenNetworkChannel(LobbyId lobbyId, std::uint8_t channelId, bool reliable);
    Result SendNetworkMessage(LobbyId lobbyId, UserId userId, std::uint8_t channelId, std::uint8_t* data, std::uint32_t dataLength);

public:
    Event<std::int64_t> OnLobbyUpdate;
    Event<std::int64_t, std::uint32_t> OnLobbyDelete;
    Event<std::int64_t, std::int64_t> OnMemberConnect;
    Event<std::int64_t, std::int64_t> OnMemberUpdate;
    Event<std::int64_t, std::int64_t> OnMemberDisconnect;
    Event<std::int64_t, std::int64_t, std::uint8_t*, std::uint32_t> OnLobbyMessage;
    Event<std::int64_t, std::int64_t, bool> OnSpeaking;
    Event<std::int64_t, std::int64_t, std::uint8_t, std::uint8_t*, std::uint32_t> OnNetworkMessage;

private:
    friend class Core;

    LobbyManager() = default;
    LobbyManager(LobbyManager const& rhs) = delete;
    LobbyManager& operator=(LobbyManager const& rhs) = delete;
    LobbyManager(LobbyManager&& rhs) = delete;
    LobbyManager& operator=(LobbyManager&& rhs) = delete;

    IDiscordLobbyManager* internal_;
    static IDiscordLobbyEvents events_;
};

typedef unsigned short int wide_char;

enum EChannelType
{
	ctUnsupported = -1,
	ctPositionX = 0,
	ctPositionY,
	ctPositionZ,
	ctRotationH,
	ctRotationP,
	ctRotationB,
	ctMaxChannel
};

struct st_BoneMotion
{
  const u32 flWorldOrient = 1 << 0;
	shared_str name;
	CEnvelope* envs[ctMaxChannel];
	Flags8 m_Flags;

	st_BoneMotion();
	void SetName(LPCSTR nm);
};

DEFINE_VECTOR(st_BoneMotion, BoneMotionVec, BoneMotionIt);

enum EMotionType
{
  mtObject = 0,
  mtSkeleton,
  ForceDWORD = u32(-1)
};

class CCustomMotion
{
public:
	shared_str name;
  
public:
	CCustomMotion();
	CCustomMotion(CCustomMotion* src);
	virtual ~CCustomMotion();
	void SetName(const char* n);
	LPCSTR Name();
	int FrameStart();
	int FrameEnd();
	float FPS();
	int Length();
	void SetParam(int s, int e, float fps);
	virtual void Save(IWriter& F);
	virtual bool Load(IReader& F);
	virtual void SaveMotion(const char* buf) = 0;
	virtual bool LoadMotion(const char* buf) =0;
  
protected:
	EMotionType mtype;
	int iFrameStart, iFrameEnd;
	float fFPS;
};

//--------------------------------------------------------------------------
class COMotion : public CCustomMotion
{
public:
	COMotion();
	COMotion(COMotion* src);
	virtual ~COMotion();
	void Clear();
	void _Evaluate(float t, Fvector& T, Fvector& R);
	virtual void Save(IWriter& F);
	virtual bool Load(IReader& F);
	virtual void SaveMotion(const char* buf);
	virtual bool LoadMotion(const char* buf);
	CEnvelope* envs[ctMaxChannel];
};

enum ESMFlags
{
	esmFX = 1 << 0,
	esmStopAtEnd = 1 << 1,
	esmNoMix = 1 << 2,
	esmSyncPart = 1 << 3,
	esmUseFootSteps = 1 << 4,
	esmRootMover = 1 << 5,
	esmIdle = 1 << 6,
	esmUseWeaponBone = 1 << 7,
};

class CSMotion: public CCustomMotion
{
public:
  u16 m_BoneOrPart;
  float fSpeed;
  float fAccrue;
  float fFalloff;
  float fPower;
  Flags8 m_Flags;
  xr_vector<motion_marks> marks;    
    
public:
  CSMotion ();
  CSMotion (CSMotion* src);
  virtual ~CSMotion ();
  void _Evaluate (int bone_idx, float t, Fvector& T, Fvector& R);
  void CopyMotion (CSMotion* src);
  st_BoneMotion* FindBoneMotion(shared_str name);
  BoneMotionVec& BoneMotions();
  Flags8 GetMotionFlags(int bone_idx);
  void add_empty_motion(shared_str const& bone_id);
  virtual void Save (IWriter& F);
  virtual bool Load (IReader& F);
  virtual void SaveMotion (const char* buf);
  virtual bool LoadMotion (const char* buf);
  void SortBonesBySkeleton(BoneVec& bones);
  void WorldRotate (int boneId, float h, float p, float b);
  void Optimize ();
  void Clear ();
  
private:
  BoneMotionVec bone_mots;
};

struct SAnimParams
{
public:
  float t_current;
	float tmp;
	float min_t;
	float max_t;
	BOOL bPlay;
	BOOL bWrapped;
  
public:
	SAnimParams();
	void Set(CCustomMotion* M);
	void Set(float start_frame, float end_frame, float fps);
	float Frame();
	void Update(float dt, float speed, bool loop);
	void Play();
	void Stop();
	void Pause(bool val);
};

class NetworkEvents final 
{
public:
    static void OnMessage(void* callbackData, DiscordNetworkPeerId peerId, DiscordNetworkChannelId channelId, uint8_t* data, uint32_t dataLength);
    static void OnRouteUpdate(void* callbackData, char const* routeData);
};

class NetworkManager final 
{
public:
    ~NetworkManager() = default;
    void GetPeerId(NetworkPeerId* peerId);
    Result Flush();
    Result OpenPeer(NetworkPeerId peerId, char const* routeData);
    Result UpdatePeer(NetworkPeerId peerId, char const* routeData);
    Result ClosePeer(NetworkPeerId peerId);
    Result OpenChannel(NetworkPeerId peerId, NetworkChannelId channelId, bool reliable);
    Result CloseChannel(NetworkPeerId peerId, NetworkChannelId channelId);
    Result SendMessage(NetworkPeerId peerId, NetworkChannelId channelId, std::uint8_t* data, std::uint32_t dataLength);
    Event<NetworkPeerId, NetworkChannelId, std::uint8_t*, std::uint32_t> OnMessage;
    Event<char const*> OnRouteUpdate;

private:
    friend class Core;

    NetworkManager() = default;
    NetworkManager(NetworkManager const& rhs) = delete;
    NetworkManager& operator=(NetworkManager const& rhs) = delete;
    NetworkManager(NetworkManager&& rhs) = delete;
    NetworkManager& operator=(NetworkManager&& rhs) = delete;

    IDiscordNetworkManager* internal_;
    static IDiscordNetworkEvents events_;
};

class CObjectAnimator
{  
public:
	CObjectAnimator();
	virtual ~CObjectAnimator();
	void Clear();
	void Load(LPCSTR name);
	LPCSTR Name();
	float& Speed();
	COMotion* Play(bool bLoop, LPCSTR name = 0);
	void Pause(bool val);
	void Stop();
	BOOL IsPlaying();
	const Fmatrix& XFORM();
	const SAnimParams& anim_param();
	bool bLoop;
	float GetLength();
	void Update(float dt);
	void DrawPath();
  
protected:
	shared_str m_Name;
	Fmatrix m_XFORM;
	SAnimParams m_MParam;
	MotionVec m_Motions;
	float m_Speed;
	COMotion* m_Current;
	void LoadMotions(LPCSTR fname);
	void SetActiveMotion(COMotion* mot);
	COMotion* FindMotionByName(LPCSTR name);
  
private:
	DEFINE_VECTOR(COMotion*, MotionVec, MotionIt);
};

class OverlayEvents final 
{
public:
    static void OnToggle(void* callbackData, bool locked);
};

class OverlayManager final 
{
public:
    ~OverlayManager() = default;
    void IsEnabled(bool* enabled);
    void IsLocked(bool* locked);
    void SetLocked(bool locked, std::function<void(Result)> callback);
    void OpenActivityInvite(ActivityActionType type, std::function<void(Result)> callback);
    void OpenGuildInvite(char const* code, std::function<void(Result)> callback);
    void OpenVoiceSettings(std::function<void(Result)> callback);
    Result InitDrawingDxgi(IDXGISwapChain* swapchain, bool useMessageForwarding);
    void OnPresent();
    void ForwardMessage(MSG* message);
    void KeyEvent(bool down, char const* keyCode, KeyVariant variant);
    void CharEvent(char const* character);
    void MouseButtonEvent(std::uint8_t down, std::int32_t clickCount, MouseButton which, std::int32_t x, std::int32_t y);
    void MouseMotionEvent(std::int32_t x, std::int32_t y);
    void ImeCommitText(char const* text);
    void ImeSetComposition(char const* text, ImeUnderline* underlines, std::uint32_t underlinesLength, std::int32_t from, std::int32_t to);
    void ImeCancelComposition();
    void SetImeCompositionRangeCallback(std::function<void(std::int32_t, std::int32_t, Rect*, std::uint32_t)> onImeCompositionRangeChanged);
    void SetImeSelectionBoundsCallback(std::function<void(Rect, Rect, bool)> onImeSelectionBoundsChanged);
    bool IsPointInsideClickZone(std::int32_t x, std::int32_t y);
    
    Event<bool> OnToggle;

private:
    friend class Core;

    OverlayManager() = default;
    OverlayManager(OverlayManager const& rhs) = delete;
    OverlayManager& operator=(OverlayManager const& rhs) = delete;
    OverlayManager(OverlayManager&& rhs) = delete;
    OverlayManager& operator=(OverlayManager&& rhs) = delete;

    IDiscordOverlayManager* internal_;
    static IDiscordOverlayEvents events_;
};

class CPerlinNoiseCustom
{  
public:
	CPerlinNoiseCustom(int seed) : mOctaves(2), mFrequency(1), mAmplitude(1), mSeed(seed), mReady(false);
	void SetParams(int oct, float freq, float amp);
	void SetOctaves(int oct);
	void SetFrequency(float freq);
	void SetAmplitude(float amp);
  
protected:
  int mSeed;
	bool mReady;
	int mOctaves;
	float mFrequency;
	float mAmplitude;
	xr_vector<float> mTimes;
  int p[SAMPLE_SIZE + SAMPLE_SIZE + 2];
};

class CPerlinNoise1D : public CPerlinNoiseCustom
{  
public:
	CPerlinNoise1D(int seed) : CPerlinNoiseCustom(seed) { mPrevContiniousTime = 0.0f; }
	float Get(float x);
	float GetContinious(float v);
  
private:
	float noise(float arg);
	void init();
  
  float g1[SAMPLE_SIZE + SAMPLE_SIZE + 2];
	float mPrevContiniousTime;
};

class CPerlinNoise2D : public CPerlinNoiseCustom
{
public:
	CPerlinNoise2D(int seed) : CPerlinNoiseCustom(seed);
	float Get(float x, float y);
  
private:
	float noise(const Fvector2& vec);
	void normalize(float v[2]);  
	void init();
  
  float g2[SAMPLE_SIZE + SAMPLE_SIZE + 2][2];
};

class CPerlinNoise3D : public CPerlinNoiseCustom
{  
public:
	CPerlinNoise3D(int seed) : CPerlinNoiseCustom(seed);
	float Get(float x, float y, float z);

private:
	float noise(const Fvector3& vec);
	void normalize(float v[3]);  
	void init();
  
  float g3[SAMPLE_SIZE + SAMPLE_SIZE + 2][3];
};

enum xrProperties
{
	xrPID_MARKER = 0,
	xrPID_MATRIX,
	xrPID_CONSTANT,
	xrPID_TEXTURE,
	xrPID_INTEGER,
	xrPID_FLOAT,
	xrPID_BOOL,
	xrPID_TOKEN,
	xrPID_CLSID,
	xrPID_OBJECT,
	xrPID_STRING,
	xrPID_MARKER_TEMPLATE,
	xrPID_FORCEDWORD = u32(-1)
};

struct xrP_Integer
{
	int value;
	int min;
	int max;

	xrP_Integer() : value(0), min(0), max(255);
};

struct xrP_Float
{
	float value;
	float min;
	float max;

	xrP_Float() : value(0), min(0), max(1);
};

struct xrP_BOOL
{
	BOOL value;

	xrP_BOOL() : value(FALSE);
};

struct Item
{
  u32 ID;
  string64 str;
};

struct xrP_TOKEN
{
	u32 IDselected;
	u32 Count;

	xrP_TOKEN() : IDselected(0), Count(0);
};

struct xrP_CLSID
{
	CLASS_ID Selected;
	u32 Count;
  
	xrP_CLSID() : Selected(0), Count(0);
};

struct xrP_Template
{
	u32 Type;
	u32 Limit;
};

class CPropertyBase
{
public:
	virtual LPCSTR getName() = 0;
	virtual LPCSTR getComment() = 0;
	virtual void Save(IWriter& fs) = 0;
	virtual void Load(IReader& fs, u16 version) = 0;
};

template <bool _is_pm, typename T>
	friend struct xr_special_free;

class CPS_Instance : public ISpatial, public ISheduled, public IRenderable 
{
public:
	CPS_Instance(bool destroy_on_game_load);
	const bool& destroy_on_game_load() const;
	virtual void PSI_destroy();
	BOOL PSI_alive();
	BOOL PSI_IsAutomatic();
	void PSI_SetLifeTime(float life_time);
	virtual void Play(bool bHudMode) = 0;
	virtual BOOL Locked();
	virtual shared_str shedule_Name() const;
	virtual void shedule_Update(u32 dt);
	virtual IRenderable* dcast_Renderable();
  
private:
  friend class IGame_Persistent;	
	bool m_destroy_on_game_load;

protected:
	int m_iLifeTime;
	BOOL m_bAutoRemove;
	BOOL m_bDead;

protected:
	virtual ~CPS_Instance();
	virtual void PSI_internal_delete();
};

class pVector : public Fvector
{
public:
	pVector(float ax, float ay, float az) { set(ax, ay, az); }
	pVector();
	float length() const;
	float length2() const;
	float operator*(const pVector& a) const;
	pVector operator*(const float s) const;
	pVector operator/(const float s) const;
	pVector operator+(const pVector& a) const;
	pVector operator-(const pVector& a) const;
	pVector operator-();
	pVector& operator+=(const pVector& a);
	pVector& operator-=(const pVector& a);
	pVector& operator*=(const float a);
	pVector& operator/=(const float a);
	pVector& operator=(const pVector& a);
	pVector operator^(const pVector& b) const;
};

struct Particle
{
  const u32 ANIMATE_CCW = (1 << 0);
	pVector pos; // 12
	pVector posB; // 12
	pVector vel; // 12
	pVector size; // 12
	pVector rot; // 12 60
	u32 color; // 4
	float age; // 4
	u16 frame; // 2
	Flags16 flags; // 2
};

enum PDomainEnum
{
	PDPoint = 0,
	PDLine = 1,
	PDTriangle = 2,
	PDPlane = 3,
	PDBox = 4,
	PDSphere = 5,
	PDCylinder = 6,
	PDCone = 7,
	PDBlob = 8,
	PDDisc = 9,
	PDRectangle = 10,
	domain_enum_force_dword = u32(-1)
};

enum PActionEnum
{
	PAAvoidID,
	PABounceID,
	PACallActionListID_obsolette,
	PACopyVertexBID,.
	PADampingID,
	PAExplosionID,
	PAFollowID,
	PAGravitateID,
	PAGravityID,
	PAJetID,
	PAKillOldID,
	PAMatchVelocityID,
	PAMoveID,
	PAOrbitLineID,
	PAOrbitPointID,
	PARandomAccelID,
	PARandomDisplaceID,
	PARandomVelocityID,
	PARestoreID,
	PASinkID,
	PASinkVelocityID,
	PASourceID,
	PASpeedLimitID,
	PATargetColorID,
	PATargetSizeID,
	PATargetRotateID,
	PATargetRotateDID,
	PATargetVelocityID,
	PATargetVelocityDID,
	PAVortexID,
	PATurbulenceID,
	PAScatterID,
	action_enum_force_dword = u32(-1)
};

class IParticleManager
{
public:
	IParticleManager();
	virtual ~IParticleManager();
	virtual int CreateEffect(u32 max_particles) = 0;
	virtual void DestroyEffect(int effect_id) = 0;
	virtual int CreateActionList() = 0;
	virtual void DestroyActionList(int alist_id) = 0;
	virtual void PlayEffect(int effect_id, int alist_id) = 0;
	virtual void StopEffect(int effect_id, int alist_id, BOOL deffered = TRUE) = 0;
	virtual void Update(int effect_id, int alist_id, float dt) = 0;
	virtual void Render(int effect_id) = 0;
	virtual void Transform(int alist_id, const Fmatrix& m, const Fvector& velocity) = 0;
	virtual void RemoveParticle(int effect_id, u32 p_id) = 0;
	virtual void SetMaxParticles(int effect_id, u32 max_particles) = 0;
	virtual void SetCallback(int effect_id, OnBirthParticleCB b, OnDeadParticleCB d, void* owner, u32 param) = 0;
	virtual void GetParticles(int effect_id, Particle*& particles, u32& cnt) = 0;
	virtual u32 GetParticlesCount(int effect_id) = 0;
	virtual ParticleAction* CreateAction(PActionEnum type) = 0;
	virtual u32 LoadActions(int alist_id, IReader& R) = 0;
	virtual void SaveActions(int alist_id, IWriter& W) = 0;
};

struct _REG_INFO
{
	void* Object;
	int Prio;
	u32 Flags;
};

struct
{
  u32 in_process : 1;
  u32 changed : 1;
};

template <class T>
class CRegistrator
{
public:
	xr_vector<_REG_INFO> R;
  
	CRegistrator();
	void Add(T* obj, int priority = REG_PRIORITY_NORMAL, u32 flags = 0);
	void Remove(T* obj);
	void Process(RP_FUNC* f);
	void Resort(void);
  
private:
	static int __cdecl _REG_Compare(const void* e1, const void* e2);
};

class pure_relcase
{  
public:
	template <typename class_type>
	pure_relcase(void (xr_stdcall class_type::* function_to_bind)(CObject*));
	virtual ~pure_relcase();
  
private:
	int m_ID;
};

struct Item
{
  Fvector P;
  Fvector Phit;
  Fvector D;
  float fSpeed;
  u32 dwTime_Life;
  u32 dwTime_Hit;
  u32 uv_set;

  void invalidate();
};

struct Particle
{
  Particle *next, *prev;
  Fmatrix mXForm;
  Fsphere bounds;
  float time;
};

enum States
{
  stIdle = 0,
  stWorking
};

class CEffect_Rain
{  
public:
	CEffect_Rain();
	~CEffect_Rain();
	void Render();
	void OnFrame();
	void InvalidateState();
	float GetRainVolume();
	float GetRainHemi();
  
private:
	FactoryPtr<IRainRender> m_pRender;
	xr_vector<Item> items;
	States state;
	xr_vector<Particle> particle_pool;
	Particle* particle_active;
	Particle* particle_idle;
	ref_sound snd_Ambient;
	float rain_volume;
	float rain_hemi = 0.0f;
  CPerlinNoise1D* RainPerlin;
  friend class dxRainRender;
  
private:
	void p_create();
	void p_destroy();
	void p_remove(Particle* P, Particle*& LST);
	void p_insert(Particle* P, Particle*& LST);
	int p_size(Particle* LST);
	Particle* p_allocate();
	void p_free(Particle* P);
	void Born(Item& dest, float radius, float speed);
	void Hit(Fvector& pos);
	BOOL RayPick(const Fvector& s, const Fvector& d, float& range, collide::rq_target tgt);
	void RenewItem(Item& dest, float height, BOOL bHit);
	void Prepare(Fvector2& offset, Fvector3& axis, float Wind_Vel, float Wind_Dir);
};

class RelationshipEvents final 
{
public:
    static void OnRefresh(void* callbackData);
    static void OnRelationshipUpdate(void* callbackData, DiscordRelationship* relationship);
};

class RelationshipManager final 
{
public:
    ~RelationshipManager() = default;

    void Filter(std::function<bool(Relationship const&)> filter);
    Result Count(std::int32_t* count);
    Result Get(UserId userId, Relationship* relationship);
    Result GetAt(std::uint32_t index, Relationship* relationship);

    Event<> OnRefresh;
    Event<Relationship const&> OnRelationshipUpdate;

private:
    friend class Core;

    RelationshipManager() = default;
    RelationshipManager(RelationshipManager const& rhs) = delete;
    RelationshipManager& operator=(RelationshipManager const& rhs) = delete;
    RelationshipManager(RelationshipManager&& rhs) = delete;
    RelationshipManager& operator=(RelationshipManager&& rhs) = delete;

    IDiscordRelationshipManager* internal_;
    static IDiscordRelationshipEvents events_;
};

enum LT
{
  DIRECT = 0,
  POINT = 1,
  SPOT = 2,
  OMNIPART = 3,
  REFLECTED = 4,
};

class IRender_Light : public xr_resource
{
public:
	virtual void set_type(LT type) = 0;
	virtual void set_active(bool) = 0;
	virtual bool get_active() = 0;
	virtual void set_shadow(bool) = 0;
	virtual void set_volumetric(bool) = 0;
	virtual void set_volumetric_quality(float) = 0;
	virtual void set_volumetric_intensity(float) = 0;
	virtual void set_volumetric_distance(float) = 0;

	virtual void set_indirect(bool);
	virtual void set_position(const Fvector& P) = 0;
	virtual void set_rotation(const Fvector& D, const Fvector& R) = 0;
	virtual void set_cone(float angle) = 0;
	virtual void set_range(float R) = 0;
	virtual void set_virtual_size(float R) = 0;
	virtual void set_texture(LPCSTR name) = 0;
	virtual void set_color(const Fcolor& C) = 0;
	virtual void set_color(float r, float g, float b) = 0;
	virtual void set_hud_mode(bool b) = 0;
	virtual bool get_hud_mode() = 0;
	virtual ~IRender_Light();
};

struct resptrcode_light : public resptr_base<IRender_Light>
{
	void destroy();
};

typedef resptr_core<IRender_Light, resptrcode_light> ref_light;

class IRender_Glow : public xr_resource
{
public:
	virtual void set_active(bool) = 0;
	virtual bool get_active() = 0;
	virtual void set_position(const Fvector& P) = 0;
	virtual void set_direction(const Fvector& P) = 0;
	virtual void set_radius(float R) = 0;
	virtual void set_texture(LPCSTR name) = 0;
	virtual void set_color(const Fcolor& C) = 0;
	virtual void set_color(float r, float g, float b) = 0;
	virtual ~IRender_Glow();
};

struct resptrcode_glow : public resptr_base<IRender_Glow>
{
	void destroy();
};

typedef resptr_core<IRender_Glow, resptrcode_glow> ref_glow;

enum mode
{
  TRACE_LIGHTS = (1 << 0),
  TRACE_SUN = (1 << 1),
  TRACE_HEMI = (1 << 2),
  TRACE_ALL = (TRACE_LIGHTS | TRACE_SUN | TRACE_HEMI),
};

class IRender_ObjectSpecific
{
public:
	virtual void force_mode(u32 mode) = 0;
	virtual float get_luminocity() = 0;
	virtual float get_luminocity_hemi() = 0;
	virtual float* get_luminocity_hemi_cube() = 0;
	virtual ~IRender_ObjectSpecific();
};

class IRender_Portal
{
public:
	virtual ~IRender_Portal();
};

class IRender_Sector
{
public:
	virtual ~IRender_Sector();
};

class IRender_Target
{
public:
	virtual void set_blur(float f) = 0;
	virtual void set_gray(float f) = 0;
	virtual void set_duality_h(float f) = 0;
	virtual void set_duality_v(float f) = 0;
	virtual void set_noise(float f) = 0;
	virtual void set_noise_scale(float f) = 0;
	virtual void set_noise_fps(float f) = 0;
	virtual void set_color_base(u32 f) = 0;
	virtual void set_color_gray(u32 f) = 0;
	virtual void set_color_add(const Fvector& f) = 0;
	virtual u32 get_width() = 0;
	virtual u32 get_height() = 0;
	virtual void set_cm_imfluence(float f) = 0;
	virtual void set_cm_interpolate(float f) = 0;
	virtual void set_cm_textures(const shared_str& tex0, const shared_str& tex1) = 0;
	virtual ~IRender_Target();
};

enum GenerationLevel
{
  GENERATION_R1 = 81,
  GENERATION_DX81 = 81,
  GENERATION_R2 = 90,
  GENERATION_DX90 = 90,
  GENERATION_forcedword = u32(-1)
};

enum ScreenshotMode
{
  SM_NORMAL = 0,
  SM_FOR_CUBEMAP = 1,
  SM_FOR_GAMESAVE = 2,
  SM_FOR_LEVELMAP = 3,
  SM_FOR_MPSENDING = 4,
  SM_forcedword = u32(-1)
};

enum RRT
{
  rtPDA = 1,
  rtSVP,
};

class IRender_interface
{
public:
	bool hud_loading;
	s32 m_skinning;
	s32 m_MSAASample;
	CFrustum ViewBase;
	CFrustum* View;
  
public:
	virtual GenerationLevel get_generation() = 0;
	virtual bool is_sun_static() = 0;
	virtual DWORD get_dx_level() = 0;
	virtual void create() = 0;
	virtual void destroy() = 0;
	virtual void reset_begin() = 0;
	virtual void reset_end() = 0;
	virtual void level_Load(IReader*) = 0;
	virtual void level_Unload() = 0;
	void shader_option_skinning(s32 mode) { m_skinning = mode; }
	virtual HRESULT shader_compile(LPCSTR name,	DWORD const* pSrcData, UINT SrcDataLen, LPCSTR pFunctionName, LPCSTR pTarget, DWORD Flags, void*& result) = 0;
	virtual void Statistics(CGameFont* F);
	virtual LPCSTR getShaderPath() = 0;
	virtual IRender_Sector* getSector(int id) = 0;
	virtual IRenderVisual* getVisual(int id) = 0;
	virtual IRender_Sector* detectSector(const Fvector& P) = 0;
	virtual IRender_Target* getTarget() = 0;
	void set_Frustum(CFrustum* O);
	virtual void set_Transform(Fmatrix* M) = 0;
	virtual void set_HUD(BOOL V) = 0;
	virtual BOOL get_HUD() = 0;
	virtual void set_Invisible(BOOL V) = 0;
	virtual void flush() = 0;
	virtual void set_Object(IRenderable* O) = 0;
	virtual void add_Occluder(Fbox2& bb_screenspace) = 0; // mask screen region as oclluded (-1..1, -1..1)
	virtual void add_Visual(IRenderVisual* V) = 0; // add visual leaf (no culling performed at all)
	virtual void add_Geometry(IRenderVisual* V) = 0; // add visual(s) (all culling performed)
	virtual void add_StaticWallmark(const wm_shader& S, const Fvector& P, float s, CDB::TRI* T, Fvector* V) = 0;
	virtual void add_StaticWallmark(IWallMarkArray* pArray, const Fvector& P, float s, CDB::TRI* T, Fvector* V, float ttl = 0.f, bool ignore_opt = false, bool random_rotation = true) = 0;
	virtual void add_StaticWallmark(IWallMarkArray* pArray, const Fvector& P, float s, CDB::TRI* T, Fvector* V, float ttl, bool ignore_opt, float rotation) = 0;
	virtual void clear_static_wallmarks() = 0;
	virtual void add_SkeletonWallmark(const Fmatrix* xf, IKinematics* obj, IWallMarkArray* pArray, const Fvector& start, const Fvector& dir, float size, float ttl = 0.f, bool ignore_opt = false) = 0;
	virtual IRender_ObjectSpecific* ros_create(IRenderable* parent) = 0;
	virtual void ros_destroy(IRender_ObjectSpecific*&) = 0;
	virtual IRender_Light* light_create() = 0;
	virtual void light_destroy(IRender_Light* p_);
	virtual IRender_Glow* glow_create() = 0;
	virtual void glow_destroy(IRender_Glow* p_);
	virtual IRenderVisual* model_CreateParticles(LPCSTR name) = 0;
	virtual IRenderVisual* model_Create(LPCSTR name, IReader* data = 0) = 0;
	virtual IRenderVisual* model_CreateChild(LPCSTR name, IReader* data) = 0;
	virtual IRenderVisual* model_Duplicate(IRenderVisual* V) = 0;
	virtual void model_Delete(IRenderVisual*& V, BOOL bDiscard = FALSE) = 0;
	virtual void model_Logging(BOOL bEnable) = 0;
	virtual void models_Prefetch() = 0;
	virtual void models_PrefetchOne(LPCSTR name) = 0;
	virtual void models_Clear(BOOL b_complete) = 0;
	virtual BOOL occ_visible(vis_data& V) = 0;
	virtual BOOL occ_visible(Fbox& B) = 0;
	virtual BOOL occ_visible(sPoly& P) = 0;
	virtual void Calculate() = 0;
	virtual void Render() = 0;
	virtual void Screenshot(ScreenshotMode mode = SM_NORMAL, LPCSTR name = 0) = 0;
	virtual void Screenshot(ScreenshotMode mode, CMemoryWriter& memory_writer) = 0;
	virtual void ScreenshotAsyncBegin() = 0;
	virtual void ScreenshotAsyncEnd(CMemoryWriter& memory_writer) = 0;
	virtual void ExportParticles();
	virtual void ImportParticles();
	virtual void rmNear() = 0;
	virtual void rmFar() = 0;
	virtual void rmNormal() = 0;
	virtual u32 memory_usage() = 0;
	virtual u32 active_phase() = 0; //Swartz: actor shadow
	virtual void RenderToTarget(RRT target) = 0;
	virtual ~IRender_interface();
  
protected:
	virtual void ScreenshotImpl(ScreenshotMode mode, LPCSTR name, CMemoryWriter* memory_writer) = 0;
};

enum
{
  flCollision = 1 << 0,
  flRendering = 1 << 1,
  flOptimizeUV = 1 << 2,
  flLIGHT_Vertex = 1 << 3,
  flLIGHT_CastShadow = 1 << 4,
  flLIGHT_Sharp = 1 << 5,
};

struct ShaderXrLcFlags
{
  u32 bCollision : 1;
  u32 bRendering : 1;
  u32 bOptimizeUV : 1;
  u32 bLIGHT_Vertex : 1;
  u32 bLIGHT_CastShadow : 1;
  u32 bLIGHT_Sharp : 1;
};

struct Shader_xrLC
{
public:
	char Name[128];
	union
	{
		Flags32 m_Flags;
		Flags flags;
	};

	float vert_translucency;
	float vert_ambient;
	float lm_density;

	Shader_xrLC();
};

DEFINE_VECTOR(Shader_xrLC, Shader_xrLCVec, Shader_xrLCIt);

class Shader_xrLC_LIB
{  
public:
	void Load(LPCSTR name);
	bool Save(LPCSTR name);
	void Unload();
	u32 GetID(LPCSTR name);
	Shader_xrLC* Get(LPCSTR name);
	Shader_xrLC* Get(int id);
	Shader_xrLC* Append(Shader_xrLC* parent = 0);
	void Remove(LPCSTR name);
	void Remove(int id);
	Shader_xrLCVec& Library();
  
private:
	Shader_xrLCVec library;
};

class ShadersExternalData-
{
public:
	Fmatrix m_script_params;
	Fvector4 hud_params;     // [zoom_rotate_factor, secondVP_zoom_factor, hud_fov, NULL]
	Fvector4 hud_fov_params; // [scope_zoom_factor, min_scope_zoom_factor, NULL, NULL]
	Fvector4 m_blender_mode; // x\y = [0 - default, 1 - night vision, 2 - thermo vision, ... ñì. common.h]

	ShadersExternalData();
}; 

enum
{
	flTKeyPresent = (1 << 0),
	flRKeyAbsent = (1 << 1),
	flTKey16IsBit = (1 << 2),
};

struct CKey
{
	Fquaternion Q; // rotation
	Fvector T; // translation
};

struct CKeyQR
{
	s16 x, y, z, w; // rotation
};

struct CKeyQT8
{
	s8 x1, y1, z1;
};

struct CKeyQT16
{
	s16 x1, y1, z1;
};

class CMotion
{
public:
	ref_smem<CKeyQR> _keysR;
	ref_smem<CKeyQT8> _keysT8;
	ref_smem<CKeyQT16> _keysT16;
	Fvector _initT;
	Fvector _sizeT;
  
public:
	void set_flags(u8 val);
	void set_flag(u8 mask, u8 val);
	BOOL test_flag(u8 mask) const;
	void set_count(u32 cnt);
	u32 get_count() const;
	float GetLength();
	u32 mem_usage();
  
private:
  u32 _flags : 8;
  u32 _count : 24;
};

class motion_marks
{
public:
	typedef std::pair<float, float> interval;
	shared_str name;
  
public:
	void Load(IReader*);
	bool is_empty() const;
	const interval* pick_mark(float const& t) const;
	bool is_mark_between(float const& t0, float const& t1) const;
	float time_to_next_mark(float time) const;
  
private:
	typedef xr_vector<interval> STORAGE;
	typedef STORAGE::iterator ITERATOR;
	typedef STORAGE::const_iterator C_ITERATOR;
	STORAGE intervals;
};

class CMotionDef
{
public:
	u16 bone_or_part;
	u16 motion;
	u16 speed; // quantized: 0..10
	u16 power; // quantized: 0..10
	u16 accrue; // quantized: 0..10
	u16 falloff; // quantized: 0..10
	u16 flags;
	xr_vector<motion_marks> marks;

	IC float Dequantize(u16 V) const;
	IC u16 Quantize(float V) const;
	void Load(IReader* MP, u32 fl, u16 vers);
	u32 mem_usage();
	float Accrue();
	float Falloff();
	float Speed();
	float Power();
	bool StopAtEnd();
};

struct accel_str_pred : public std::binary_function<shared_str, shared_str, bool>
{
	bool operator()(const shared_str& x, const shared_str& y) const ;
};

typedef xr_map<shared_str, u16, accel_str_pred> accel_map;
DEFINE_VECTOR(CMotionDef, MotionDefVec, MotionDefVecIt);
DEFINE_VECTOR(CMotion, MotionVec, MotionVecIt);
DEFINE_VECTOR(MotionVec*, BoneMotionsVec, BoneMotionsVecIt);
DEFINE_MAP(shared_str, MotionVec, BoneMotionMap, BoneMotionMapIt);

class CPartDef
{
public:
	shared_str Name;
	xr_vector<u32> bones;
	CPartDef() : Name(0);
	u32 mem_usage();
};

class CPartition
{  
public:
	CPartDef& operator[](u16 id);
	const CPartDef& part(u16 id) const;
	u16 part_id(const shared_str& name) const;
	u32 mem_usage();
	void load(IKinematics* V, LPCSTR model_name);
	u8 count() const;
  
private:
	CPartDef P[MAX_PARTS];
};

struct motions_value
{
	accel_map m_motion_map; // motion associations
	accel_map m_cycle; // motion data itself (shared)
	accel_map m_fx; // motion data itself (shared)
	CPartition m_partition; // partition
	u32 m_dwReference;
	BoneMotionMap m_motions;
	MotionDefVec m_mdefs;
	shared_str m_id;

	BOOL load(LPCSTR N, IReader* data, vecBones* bones);
	MotionVec* bone_motions(shared_str bone_name);
	u32 mem_usage();
};

class motions_container
{  
public:
	motions_container();
	~motions_container();
	bool has(shared_str key);
	motions_value* dock(shared_str key, IReader* data, vecBones* bones);
	void dump();
	void clean(bool force_destroy);
  
private:
	DEFINE_MAP(shared_str, motions_value*, SharedMotionsMap, SharedMotionsMapIt);
	SharedMotionsMap container;
};

class shared_motions
{
public:
	bool create(shared_str key, IReader* data, vecBones* bones);
	bool create(shared_motions const& rhs);
	shared_motions();
	shared_motions(shared_motions const& rhs);
	~shared_motions();
	shared_motions& operator=(shared_motions const& rhs);
	bool operator==(shared_motions const& rhs) const;
	MotionVec* bone_motions(const shared_str& bone_name);
	accel_map* motion_map();
	accel_map* cycle();
	accel_map* fx();
	CPartition* partition();
	MotionDefVec* motion_defs();
	CMotionDef* motion_def(u16 idx);
	const shared_str& id() const;
  
private:
	motions_value* p_;
  
protected:
	void destroy();
};

struct SMarker
{
  EStyle m_eStyle;
  float m_fPos;
  u32 m_dwColor;
};

enum EStyle
{
  stBar,
  stCurve,
  stBarLine,
  stPoint,
  stVert,
  stHor,
};

struct SSubGraph
{
  EStyle style;
  ElementsDeq elements;
  SSubGraph(EStyle s);
  void SetStyle(EStyle s);
};

struct SElement
{
  u32 color;
  float data;

  SElement(float d, u32 clr);
};

class CStatGraph : public pureRender
{
public:
	CStatGraph();
	~CStatGraph();
	virtual void OnRender();
	void OnDeviceCreate();
	void OnDeviceDestroy();
	void SetStyle(EStyle s, u32 SubGraphID = 0);
	void SetRect(int l, int t, int w, int h, u32 rect_clr, u32 back_clr);
	void SetGrid(int w_div, float w_step, int h_div, float h_step, u32 grid_clr, u32 base_clr);
	void SetMinMax(float _mn, float _mx, u32 item_count);
	void AppendItem(float d, u32 clr, u32 SubGraphID = 0);	
  u32 AppendSubGraph(EStyle S);
	void AddMarker(EStyle Style, float pos, u32 Color);
	const SMarker& Marker(u32 ID);
	void UpdateMarkerPos(u32 ID, float NewPos);
	void ClearMarkers();
	void RemoveMarker(u32 ID);
  
protected:
	DEFINE_DEQUE(SElement, ElementsDeq, ElementsDeqIt);
	DEFINE_VECTOR(SSubGraph, SubGraphVec, SubGraphVecIt);
	SubGraphVec subgraphs;
	float mn, mx;
	u32 max_item_count;
	Ivector2 lt, rb;
	Ivector2 grid;
	Fvector2 grid_step;
	u32 grid_color;
	u32 base_color;
	u32 rect_color;
	u32 back_color;
	FactoryPtr<IStatGraphRender> m_pRender;
	DEFINE_DEQUE(SMarker, MarkersDeq, MarkersDeqIt);
	MarkersDeq m_Markers;
  
private:
	friend class dxStatGraphRender;
};

class optimizer
{
public:
	optimizer();
	BOOL enabled();
	void enable();
	void disable();
	void update(float value);
  
private:
	float average_;
	BOOL enabled_;  
};

class CStatsPhysics
{
public:
	CStatTimer ph_collision; // collision
	CStatTimer ph_core; // integrate
	CStatTimer Physics; // movement+collision
};

class ENGINE_API CStats :	public pureRender, public CStatsPhysics
{
public:
	CGameFont* pFont;
	float fFPS, fRFPS, fTPS; // FPS, RenderFPS, TPS
	float fMem_calls;
	u32 dwMem_calls;
	u32 dwSND_Played, dwSND_Allocated; // Play/Alloc
	float fShedulerLoad;
	CStatTimer EngineTOTAL; //
	CStatTimer Sheduler; //
	CStatTimer UpdateClient; //
	u32 UpdateClient_updated; //
	u32 UpdateClient_crows; //
	u32 UpdateClient_active; //
	u32 UpdateClient_total; //
	u32 Particles_starting; // starting
	u32 Particles_active; // active
	u32 Particles_destroy; // destroying
	CStatTimer AI_Think; // thinking
	CStatTimer AI_Range; // query: range
	CStatTimer AI_Path; // query: path
	CStatTimer AI_Node; // query: node
	CStatTimer AI_Vis; // visibility detection - total
	CStatTimer AI_Vis_Query; // visibility detection - portal traversal and frustum culling
	CStatTimer AI_Vis_RayTests; // visibility detection - ray casting
	CStatTimer RenderTOTAL; //
	CStatTimer RenderTOTAL_Real;
	CStatTimer RenderCALC; // portal traversal, frustum culling, entities "renderable_Render"
	CStatTimer RenderCALC_HOM; // HOM rendering
	CStatTimer Animation; // skeleton calculation
	CStatTimer RenderDUMP; // actual primitive rendering
	CStatTimer RenderDUMP_Wait; // ...waiting something back (queries results, etc.)
	CStatTimer RenderDUMP_Wait_S; // ...frame-limit sync
	CStatTimer RenderDUMP_RT; // ...render-targets
	CStatTimer RenderDUMP_SKIN; // ...skinning
	CStatTimer RenderDUMP_HUD; // ...hud rendering
	CStatTimer RenderDUMP_Glows; // ...glows vis-testing,sorting,render
	CStatTimer RenderDUMP_Lights; // ...d-lights building/rendering
	CStatTimer RenderDUMP_WM; // ...wallmark sorting, rendering
	u32 RenderDUMP_WMS_Count; // ...number of static wallmark
	u32 RenderDUMP_WMD_Count; // ...number of dynamic wallmark
	u32 RenderDUMP_WMT_Count; // ...number of wallmark tri
	CStatTimer RenderDUMP_DT_VIS; // ...details visibility detection
	CStatTimer RenderDUMP_DT_Render; // ...details rendering
	CStatTimer RenderDUMP_DT_Cache; // ...details slot cache access
	u32 RenderDUMP_DT_Count; // ...number of DT-elements
	CStatTimer RenderDUMP_Pcalc; // ...projectors building
	CStatTimer RenderDUMP_Scalc; // ...shadows building
	CStatTimer RenderDUMP_Srender; // ...shadows render
	CStatTimer Sound; // total time taken by sound subsystem (accurate only in single-threaded mode)
	CStatTimer Input; // total time taken by input subsystem (accurate only in single-threaded mode)
	CStatTimer clRAY; // total: ray-testing
	CStatTimer clBOX; // total: box query
	CStatTimer clFRUSTUM; // total: frustum query
	CStatTimer netClient1;
	CStatTimer netClient2;
	CStatTimer netServer;
	CStatTimer netClientCompressor;
	CStatTimer netServerCompressor;
	CStatTimer TEST0; // debug counter
	CStatTimer TEST1; // debug counter
	CStatTimer TEST2; // debug counter
	CStatTimer TEST3; // debug counter
	shared_str eval_line_1;
	shared_str eval_line_2;
	shared_str eval_line_3;
	xr_vector<shared_str> errors;
	CRegistrator<pureStats> seqStats;
  
public:
	CStats();
	~CStats();
  void Show(void);
	virtual void OnRender();
	void OnDeviceCreate(void);
	void OnDeviceDestroy(void);
	IC CGameFont* Font() { return pFont; }

private:
	FactoryPtr<IStatsRender> m_pRender;
};

enum
{
	st_sound = (1 << 0),
	st_sound_min_dist = (1 << 1),
	st_sound_max_dist = (1 << 2),
	st_sound_ai_dist = (1 << 3),
	st_sound_info_name = (1 << 4),
	st_sound_info_object = (1 << 5),
};

class StorageManager final 
{
public:
  ~StorageManager() = default;
  Result Read(char const* name, std::uint8_t* data, std::uint32_t dataLength, std::uint32_t* read);
  void ReadAsync(char const* name, std::function<void(Result, std::uint8_t*, std::uint32_t)> callback);
  void ReadAsyncPartial(char const* name, std::uint64_t offset, std::uint64_t length, std::function<void(Result, std::uint8_t*, std::uint32_t)> callback);
  Result Write(char const* name, std::uint8_t* data, std::uint32_t dataLength);
  void WriteAsync(char const* name, std::uint8_t* data, std::uint32_t dataLength, std::function<void(Result)> callback);
  Result Delete(char const* name);
  Result Exists(char const* name, bool* exists);
  void Count(std::int32_t* count);
  Result Stat(char const* name, FileStat* stat);
  Result StatAt(std::int32_t index, FileStat* stat);
  Result GetPath(char path[4096]);

private:
  friend class Core;

  StorageManager() = default;
  StorageManager(StorageManager const& rhs) = delete;
  StorageManager& operator=(StorageManager const& rhs) = delete;
  StorageManager(StorageManager&& rhs) = delete;
  StorageManager& operator=(StorageManager&& rhs) = delete;

  IDiscordStorageManager* internal_;
  static IDiscordStorageEvents events_;
};

class StoreEvents final 
{
public:
  static void OnEntitlementCreate(void* callbackData, DiscordEntitlement* entitlement);
  static void OnEntitlementDelete(void* callbackData, DiscordEntitlement* entitlement);
};

class StoreManager final 
{
public:
  ~StoreManager() = default;

  void FetchSkus(std::function<void(Result)> callback);
  void CountSkus(std::int32_t* count);
  Result GetSku(Snowflake skuId, Sku* sku);
  Result GetSkuAt(std::int32_t index, Sku* sku);
  void FetchEntitlements(std::function<void(Result)> callback);
  void CountEntitlements(std::int32_t* count);
  Result GetEntitlement(Snowflake entitlementId, Entitlement* entitlement);
  Result GetEntitlementAt(std::int32_t index, Entitlement* entitlement);
  Result HasSkuEntitlement(Snowflake skuId, bool* hasEntitlement);
  void StartPurchase(Snowflake skuId, std::function<void(Result)> callback);

  Event<Entitlement const&> OnEntitlementCreate;
  Event<Entitlement const&> OnEntitlementDelete;

private:
  friend class Core;

  StoreManager() = default;
  StoreManager(StoreManager const& rhs) = delete;
  StoreManager& operator=(StoreManager const& rhs) = delete;
  StoreManager(StoreManager&& rhs) = delete;
  StoreManager& operator=(StoreManager&& rhs) = delete;

  IDiscordStoreManager* internal_;
  static IDiscordStoreEvents events_;
};

class CTextConsole : public CConsole
{
public:
	CTextConsole();
	virtual ~CTextConsole();
	virtual void Initialize();
	virtual void Destroy();
	virtual void OnRender();
	virtual void _BCL OnFrame();
  void CreateConsoleWnd();
	void CreateLogWnd();
  void DrawLog(HDC hDC, RECT* pRect);
	void AddString(LPCSTR string);
	void OnPaint();
  
private:
	typedef CConsole inherited;

	HWND* m_pMainWnd;
	HWND m_hConsoleWnd;
	HWND m_hLogWnd;  
	bool m_bScrollLog;
	u32 m_dwStartLine;
	HFONT m_hLogWndFont;
	HFONT m_hPrevFont;
	HBRUSH m_hBackGroundBrush;
	HDC m_hDC_LogWnd;
	HDC m_hDC_LogWnd_BackBuffer;
	HBITMAP m_hBB_BM, m_hOld_BM;
	bool m_bNeedUpdate;
	u32 m_dwLastUpdateTime;
	u32 m_last_time;
	CServerInfo m_server_info;
};

struct SFlare
{
  float fOpacity;
  Fvector2 fRadius;
  shared_str texture;
  shared_str shader;
  FactoryPtr<IFlareRender> m_pFlare;

  SFlare();
};

struct SThunderboltDesc
{
public:
	FactoryPtr<IThunderboltDescRender> m_pRender;
	ref_sound snd;
	SFlare* m_GradientTop;
	SFlare* m_GradientCenter;
	shared_str name;
	CLAItem* color_anim;
  
public:
	SThunderboltDesc();
	~SThunderboltDesc();
	void load(CInifile& pIni, shared_str const& sect);
	void create_top_gradient(CInifile& pIni, shared_str const& sect);
	void create_center_gradient(CInifile& pIni, shared_str const& sect);
};

struct SThunderboltCollection
{
public:
	DEFINE_VECTOR(SThunderboltDesc*, DescVec, DescIt);
	DescVec palette;
	shared_str section;
  
public:
	SThunderboltCollection();
	~SThunderboltCollection();
	void load(CInifile* pIni, CInifile* thunderbolts, LPCSTR sect);
	SThunderboltDesc* GetRandomDesc();
};

enum EState
{
  stIdle,
  stWorking
};

class CEffect_Thunderbolt
{  
public:
	CEffect_Thunderbolt();
	~CEffect_Thunderbolt();
	void OnFrame(shared_str id, float period, float duration);
	void Render();
	shared_str AppendDef(CEnvironment& environment, CInifile* pIni, CInifile* thunderbolts, LPCSTR sect);

protected:
	DEFINE_VECTOR(SThunderboltCollection*, CollectionVec, CollectionVecIt);
	CollectionVec collection;
	SThunderboltDesc* current;  

private:
  friend class dxThunderboltRender;

	Fmatrix current_xform;
	Fvector3 current_direction;
	FactoryPtr<IThunderboltRender> m_pRender;
	EState state;
	Fvector lightning_center;
	float lightning_size;
	float lightning_phase;
	float life_time;
	float current_time;
	float next_lightning_time;
	BOOL bEnabled;

private:
	BOOL RayPick(const Fvector& s, const Fvector& d, float& range);
	void Bolt(shared_str id, float period, float life_time);
};

typedef struct
{
	FOURCC fccType;
	FOURCC fccHandler;
	DWORD dwFlags;
	DWORD dwPriority;
	DWORD dwInitialFrames;
	DWORD dwScale;
	DWORD dwRate;
	DWORD dwStart;
	DWORD dwLength;
	DWORD dwSuggestedBufferSize;
	DWORD dwQuality;
	DWORD dwSampleSize;

	struct
	{
		WORD left;
		WORD top;
		WORD right;
		WORD bottom;
	};
} AVIStreamHeaderCustom;

class CAviPlayerCustom
{
public:
  DWORD m_dwWidth, m_dwHeight;

public:
	CAviPlayerCustom();
	~CAviPlayerCustom();
	VOID GetSize(DWORD* dwWidth, DWORD* dwHeight);
	BOOL Load(char* fname);
	BOOL GetFrame(BYTE** pDest);
	BOOL NeedUpdate();
	INT SetSpeed(INT nPercent);
  
protected:
	CAviPlayerCustom* alpha;
	AVIINDEXENTRY* m_pMovieIndex;
	BYTE* m_pMovieData;
	HIC m_aviIC;
	BYTE* m_pDecompressedBuf;
	BITMAPINFOHEADER m_biOutFormat;
	BITMAPINFOHEADER m_biInFormat;
	float m_fRate; // стандартная скорость, fps
	float m_fCurrentRate; // текущая скорость, fps
	DWORD m_dwFrameTotal;
	DWORD m_dwFrameCurrent;
	u32 m_dwFirstFrameOffset;

protected:
	DWORD CalcFrame();
	BOOL DecompressFrame(DWORD dwFrameNum);
	VOID PreRoll(DWORD dwFrameNum);
};

enum class Result 
{
    Ok = 0,
    ServiceUnavailable = 1,
    InvalidVersion = 2,
    LockFailed = 3,
    InternalError = 4,
    InvalidPayload = 5,
    InvalidCommand = 6,
    InvalidPermissions = 7,
    NotFetched = 8,
    NotFound = 9,
    Conflict = 10,
    InvalidSecret = 11,
    InvalidJoinSecret = 12,
    NoEligibleActivity = 13,
    InvalidInvite = 14,
    NotAuthenticated = 15,
    InvalidAccessToken = 16,
    ApplicationMismatch = 17,
    InvalidDataUrl = 18,
    InvalidBase64 = 19,
    NotFiltered = 20,
    LobbyFull = 21,
    InvalidLobbySecret = 22,
    InvalidFilename = 23,
    InvalidFileSize = 24,
    InvalidEntitlement = 25,
    NotInstalled = 26,
    NotRunning = 27,
    InsufficientBuffer = 28,
    PurchaseCanceled = 29,
    InvalidGuild = 30,
    InvalidEvent = 31,
    InvalidChannel = 32,
    InvalidOrigin = 33,
    RateLimited = 34,
    OAuth2Error = 35,
    SelectChannelTimeout = 36,
    GetGuildTimeout = 37,
    SelectVoiceForceRequired = 38,
    CaptureShortcutAlreadyListening = 39,
    UnauthorizedForAchievement = 40,
    InvalidGiftCode = 41,
    PurchaseError = 42,
    TransactionAborted = 43,
    DrawingInitFailed = 44,
};

enum class CreateFlags 
{
    Default = 0,
    NoRequireDiscord = 1,
};

enum class LogLevel 
{
    Error = 1,
    Warn,
    Info,
    Debug,
};

enum class UserFlag 
{
    Partner = 2,
    HypeSquadEvents = 4,
    HypeSquadHouse1 = 64,
    HypeSquadHouse2 = 128,
    HypeSquadHouse3 = 256,
};

enum class PremiumType 
{
    None = 0,
    Tier1 = 1,
    Tier2 = 2,
};

enum class ImageType 
{
    User,
};

enum class ActivityType 
{
    Playing,
    Streaming,
    Listening,
    Watching,
};

enum class ActivityActionType 
{
    Join = 1,
    Spectate,
};

enum class ActivityJoinRequestReply 
{
    No,
    Yes,
    Ignore,
};

enum class Status 
{
    Offline = 0,
    Online = 1,
    Idle = 2,
    DoNotDisturb = 3,
};

enum class RelationshipType 
{
    None,
    Friend,
    Blocked,
    PendingIncoming,
    PendingOutgoing,
    Implicit,
};

enum class LobbyType 
{
    Private = 1,
    Public,
};

enum class LobbySearchComparison 
{
    LessThanOrEqual = -2,
    LessThan,
    Equal,
    GreaterThan,
    GreaterThanOrEqual,
    NotEqual,
};

enum class LobbySearchCast 
{
    String = 1,
    Number,
};

enum class LobbySearchDistance 
{
    Local,
    Default,
    Extended,
    Global,
};

enum class KeyVariant 
{
    Normal,
    Right,
    Left,
};

enum class MouseButton 
{
    Left,
    Middle,
    Right,
};

enum class EntitlementType 
{
    Purchase = 1,
    PremiumSubscription,
    DeveloperGift,
    TestModePurchase,
    FreePurchase,
    UserGift,
    PremiumPurchase,
};

enum class SkuType 
{
    Application = 1,
    DLC,
    Consumable,
    Bundle,
};

enum class InputModeType 
{
    VoiceActivity = 0,
    PushToTalk,
};

using ClientId = std::int64_t;
using Version = std::int32_t;
using Snowflake = std::int64_t;
using Timestamp = std::int64_t;
using UserId = Snowflake;
using Locale = char const*;
using Branch = char const*;
using LobbyId = Snowflake;
using LobbySecret = char const*;
using MetadataKey = char const*;
using MetadataValue = char const*;
using NetworkPeerId = std::uint64_t;
using NetworkChannelId = std::uint8_t;
using Path = char const*;
using DateTime = char const*;

class User final 
{
public:
    void SetId(UserId id);
    UserId GetId() const;
    void SetUsername(char const* username);
    char const* GetUsername() const;
    void SetDiscriminator(char const* discriminator);
    char const* GetDiscriminator() const;
    void SetAvatar(char const* avatar);
    char const* GetAvatar() const;
    void SetBot(bool bot);
    bool GetBot() const;

private:
    DiscordUser internal_;
};

class OAuth2Token final 
{
public:
    void SetAccessToken(char const* accessToken);
    char const* GetAccessToken() const;
    void SetScopes(char const* scopes);
    char const* GetScopes() const;
    void SetExpires(Timestamp expires);
    Timestamp GetExpires() const;

private:
    DiscordOAuth2Token internal_;
};

class ImageHandle final 
{
public:
    void SetType(ImageType type);
    ImageType GetType() const;
    void SetId(std::int64_t id);
    std::int64_t GetId() const;
    void SetSize(std::uint32_t size);
    std::uint32_t GetSize() const;

private:
    DiscordImageHandle internal_;
};

class ImageDimensions final 
{
public:
    void SetWidth(std::uint32_t width);
    std::uint32_t GetWidth() const;
    void SetHeight(std::uint32_t height);
    std::uint32_t GetHeight() const;

private:
    DiscordImageDimensions internal_;
};

class ActivityTimestamps final 
{
public:
    void SetStart(Timestamp start);
    Timestamp GetStart() const;
    void SetEnd(Timestamp end);
    Timestamp GetEnd() const;

private:
    DiscordActivityTimestamps internal_;
};

class ActivityAssets final 
{
public:
    void SetLargeImage(char const* largeImage);
    char const* GetLargeImage() const;
    void SetLargeText(char const* largeText);
    char const* GetLargeText() const;
    void SetSmallImage(char const* smallImage);
    char const* GetSmallImage() const;
    void SetSmallText(char const* smallText);
    char const* GetSmallText() const;

private:
    DiscordActivityAssets internal_;
};

class PartySize final 
{
public:
    void SetCurrentSize(std::int32_t currentSize);
    std::int32_t GetCurrentSize() const;
    void SetMaxSize(std::int32_t maxSize);
    std::int32_t GetMaxSize() const;

private:
    DiscordPartySize internal_;
};

class ActivityParty final 
{
public:
    void SetId(char const* id);
    char const* GetId() const;
    PartySize& GetSize();
    PartySize const& GetSize() const;

private:
    DiscordActivityParty internal_;
};

class ActivitySecrets final 
{
public:
    void SetMatch(char const* match);
    char const* GetMatch() const;
    void SetJoin(char const* join);
    char const* GetJoin() const;
    void SetSpectate(char const* spectate);
    char const* GetSpectate() const;

private:
    DiscordActivitySecrets internal_;
};

class Activity final 
{
public:
    void SetType(ActivityType type);
    ActivityType GetType() const;
    void SetApplicationId(std::int64_t applicationId);
    std::int64_t GetApplicationId() const;
    void SetName(char const* name);
    char const* GetName() const;
    void SetState(char const* state);
    char const* GetState() const;
    void SetDetails(char const* details);
    char const* GetDetails() const;
    ActivityTimestamps& GetTimestamps();
    ActivityTimestamps const& GetTimestamps() const;
    ActivityAssets& GetAssets();
    ActivityAssets const& GetAssets() const;
    ActivityParty& GetParty();
    ActivityParty const& GetParty() const;
    ActivitySecrets& GetSecrets();
    ActivitySecrets const& GetSecrets() const;
    void SetInstance(bool instance);
    bool GetInstance() const;

private:
    DiscordActivity internal_;
};

class Presence final 
{
public:
    void SetStatus(Status status);
    Status GetStatus() const;
    Activity& GetActivity();
    Activity const& GetActivity() const;

private:
    DiscordPresence internal_;
};

class Relationship final 
{
public:
    void SetType(RelationshipType type);
    RelationshipType GetType() const;
    User& GetUser();
    User const& GetUser() const;
    Presence& GetPresence();
    Presence const& GetPresence() const;

private:
    DiscordRelationship internal_;
};

class Lobby final 
{
public:
    void SetId(LobbyId id);
    LobbyId GetId() const;
    void SetType(LobbyType type);
    LobbyType GetType() const;
    void SetOwnerId(UserId ownerId);
    UserId GetOwnerId() const;
    void SetSecret(LobbySecret secret);
    LobbySecret GetSecret() const;
    void SetCapacity(std::uint32_t capacity);
    std::uint32_t GetCapacity() const;
    void SetLocked(bool locked);
    bool GetLocked() const;

private:
    DiscordLobby internal_;
};

class ImeUnderline final 
{
public:
    void SetFrom(std::int32_t from);
    std::int32_t GetFrom() const;
    void SetTo(std::int32_t to);
    std::int32_t GetTo() const;
    void SetColor(std::uint32_t color);
    std::uint32_t GetColor() const;
    void SetBackgroundColor(std::uint32_t backgroundColor);
    std::uint32_t GetBackgroundColor() const;
    void SetThick(bool thick);
    bool GetThick() const;

private:
    DiscordImeUnderline internal_;
};

class Rect final 
{
public:
    void SetLeft(std::int32_t left);
    std::int32_t GetLeft() const;
    void SetTop(std::int32_t top);
    std::int32_t GetTop() const;
    void SetRight(std::int32_t right);
    std::int32_t GetRight() const;
    void SetBottom(std::int32_t bottom);
    std::int32_t GetBottom() const;

private:
    DiscordRect internal_;
};

class FileStat final 
{
public:
    void SetFilename(char const* filename);
    char const* GetFilename() const;
    void SetSize(std::uint64_t size);
    std::uint64_t GetSize() const;
    void SetLastModified(std::uint64_t lastModified);
    std::uint64_t GetLastModified() const;

private:
    DiscordFileStat internal_;
};

class Entitlement final 
{
public:
    void SetId(Snowflake id);
    Snowflake GetId() const;
    void SetType(EntitlementType type);
    EntitlementType GetType() const;
    void SetSkuId(Snowflake skuId);
    Snowflake GetSkuId() const;

private:
    DiscordEntitlement internal_;
};

class SkuPrice final 
{
public:
    void SetAmount(std::uint32_t amount);
    std::uint32_t GetAmount() const;
    void SetCurrency(char const* currency);
    char const* GetCurrency() const;

private:
    DiscordSkuPrice internal_;
};

class Sku final 
{
public:
    void SetId(Snowflake id);
    Snowflake GetId() const;
    void SetType(SkuType type);
    SkuType GetType() const;
    void SetName(char const* name);
    char const* GetName() const;
    SkuPrice& GetPrice();
    SkuPrice const& GetPrice() const;

private:
    DiscordSku internal_;
};

class InputMode final 
{
public:
    void SetType(InputModeType type);
    InputModeType GetType() const;
    void SetShortcut(char const* shortcut);
    char const* GetShortcut() const;

private:
    DiscordInputMode internal_;
};

class UserAchievement final 
{
public:
    void SetUserId(Snowflake userId);
    Snowflake GetUserId() const;
    void SetAchievementId(Snowflake achievementId);
    Snowflake GetAchievementId() const;
    void SetPercentComplete(std::uint8_t percentComplete);
    std::uint8_t GetPercentComplete() const;
    void SetUnlockedAt(DateTime unlockedAt);
    DateTime GetUnlockedAt() const;

private:
    DiscordUserAchievement internal_;
};

class LobbyTransaction final 
{
public:
    Result SetType(LobbyType type);
    Result SetOwner(UserId ownerId);
    Result SetCapacity(std::uint32_t capacity);
    Result SetMetadata(MetadataKey key, MetadataValue value);
    Result DeleteMetadata(MetadataKey key);
    Result SetLocked(bool locked);

    IDiscordLobbyTransaction** Receive();
    IDiscordLobbyTransaction* Internal();

private:
    IDiscordLobbyTransaction* internal_;
};

class LobbyMemberTransaction final 
{
public:
    Result SetMetadata(MetadataKey key, MetadataValue value);
    Result DeleteMetadata(MetadataKey key);
    IDiscordLobbyMemberTransaction** Receive();
    IDiscordLobbyMemberTransaction* Internal();

private:
    IDiscordLobbyMemberTransaction* internal_;
};

class LobbySearchQuery final 
{
public:
    Result Filter(MetadataKey key, LobbySearchComparison comparison, LobbySearchCast cast, MetadataValue value);
    Result Sort(MetadataKey key, LobbySearchCast cast, MetadataValue value);
    Result Limit(std::uint32_t limit);
    Result Distance(LobbySearchDistance distance);
    IDiscordLobbySearchQuery** Receive();
    IDiscordLobbySearchQuery* Internal();

private:
    IDiscordLobbySearchQuery* internal_;
};

class UserEvents final 
{
public:
  static void OnCurrentUserUpdate(void* callbackData);
};

class UserManager final 
{
public:
    ~UserManager() = default;

    Result GetCurrentUser(User* currentUser);
    void GetUser(UserId userId, std::function<void(Result, User const&)> callback);
    Result GetCurrentUserPremiumType(PremiumType* premiumType);
    Result CurrentUserHasFlag(UserFlag flag, bool* hasFlag);

    Event<> OnCurrentUserUpdate;

private:
    friend class Core;

    UserManager() = default;
    UserManager(UserManager const& rhs) = delete;
    UserManager& operator=(UserManager const& rhs) = delete;
    UserManager(UserManager&& rhs) = delete;
    UserManager& operator=(UserManager&& rhs) = delete;

    IDiscordUserManager* internal_;
    static IDiscordUserEvents events_;
};

struct vis_data
{
	Fsphere sphere; //
	Fbox box; //
	u32 marker; // for different sub-renders
	u32 accept_frame; // when it was requisted accepted for main render
	u32 hom_frame; // when to perform test - shedule
	u32 hom_tested; // when it was last time tested

	void clear();
};

class VoiceEvents final 
{
public:
  static void OnSettingsUpdate(void* callbackData);
};

class VoiceManager final 
{
public:
    ~VoiceManager() = default;

    Result GetInputMode(InputMode* inputMode);
    void SetInputMode(InputMode inputMode, std::function<void(Result)> callback);
    Result IsSelfMute(bool* mute);
    Result SetSelfMute(bool mute);
    Result IsSelfDeaf(bool* deaf);
    Result SetSelfDeaf(bool deaf);
    Result IsLocalMute(Snowflake userId, bool* mute);
    Result SetLocalMute(Snowflake userId, bool mute);
    Result GetLocalVolume(Snowflake userId, std::uint8_t* volume);
    Result SetLocalVolume(Snowflake userId, std::uint8_t volume);

    Event<> OnSettingsUpdate;

private:
    friend class Core;

    VoiceManager() = default;
    VoiceManager(VoiceManager const& rhs) = delete;
    VoiceManager& operator=(VoiceManager const& rhs) = delete;
    VoiceManager(VoiceManager&& rhs) = delete;
    VoiceManager& operator=(VoiceManager&& rhs) = delete;

    IDiscordVoiceManager* internal_;
    static IDiscordVoiceEvents events_;
};

enum EFunction
{
  fCONSTANT = 0,
  fSIN,
  fTRIANGLE,
  fSQUARE,
  fSAWTOOTH,
  fINVSAWTOOTH,
  fFORCE32 = u32(-1)
};

struct WaveForm
{
public:
	EFunction F;
	float arg[4];	

	WaveForm();
  float Calculate(float t);
	BOOL Similar(const WaveForm& W) const;
  float signf(float t);
	float Func(float t);
};

struct sLevelInfo
{
  char* folder;
  char* name;
};

class CApplication : public pureFrame, public IEventReceiver
{  
public:
  string2048 ls_header;
	string2048 ls_tip_number;
	string2048 ls_tip;
	CGameFont* pFontSystem;
	xr_vector<sLevelInfo> Levels;
	u32 Level_Current;
  
public:
	void Level_Scan();
	int Level_ID(LPCSTR name, LPCSTR ver, bool bSet);
	void Level_Set(u32 ID);
	void LoadAllArchives();
	CInifile* GetArchiveHeader(LPCSTR name, LPCSTR ver);
	void LoadBegin();
	void LoadEnd();
	void LoadTitleInt(LPCSTR str1, LPCSTR str2, LPCSTR str3);
	void LoadStage();
	void LoadSwitch();
	void LoadDraw();
	virtual void OnEvent(EVENT E, u64 P1, u64 P2);
	CApplication();
	virtual ~CApplication();
	virtual void _BCL OnFrame();
	void load_draw_internal();
	void destroy_loading_shaders();
  
private:
  friend class dxApplicationRender;  
	FactoryPtr<IApplicationRender> m_pRender;
	int max_load_stage;
	int load_stage;
	u32 ll_dwReference;
	EVENT eQuit;
	EVENT eStart;
	EVENT eStartLoad;
	EVENT eDisconnect;
	EVENT eConsole;
	EVENT eStartMPDemo;

private:
	void Level_Append(LPCSTR lname);
};

struct rpc_info
{
	bool mainmenu;
	bool loadscreen;
	bool ingame;
	bool ex_update;
	bool ironman;
	bool godmode;
	int possessed_lives;
	int health;
	int lives_left;
	int level_icon_index;
	char task_name[128];
	char faction_name[128];
	char rank_name[128];
	char reputation[128];
	char level_name[128];
	char gamemode[128];
	LPCSTR currenttime;
	LPCSTR faction;
	LPCSTR level;
};

struct rpc_strings
{
	char loading[128];
	char mainmenu[128];
	char paused[128];
	char health[128];
	char livesleft[128];
	char dead[128];
	char livesleftsingle[128];
	char livespossessed[128];
	char livespossessedsingle[128];
	char godmode[128];
};

struct clQueryTri
{
	Fvector p[3];
	const CDB::TRI* T;
};

struct clQueryCollision
{
	xr_vector<CObject*> objects; // affected objects
	xr_vector<clQueryTri> tris; // triangles (if queried)
	xr_vector<Fobb> boxes; // boxes/ellipsoids (if queried)
	xr_vector<Fvector4> spheres; // spheres (if queried)

	IC void Clear();
	IC void AddTri(const Fmatrix& m, const CDB::TRI* one, const Fvector* verts);
	IC void AddTri(const CDB::TRI* one, const Fvector* verts);
	IC void AddBox(const Fmatrix& M, const Fbox& B);
	IC void AddBox(const Fobb& B);
};

enum ECollisionFormType
{
	cftObject,
	cftShape
};

class ENGINE_API ICollisionForm
{
	friend class CObjectSpace;
protected:
	CObject* owner; // владелец
	u32 dwQueryID;
protected:
	Fbox bv_box; // (Local) BBox объекта
	Fsphere bv_sphere; // (Local) Sphere
private:
	ECollisionFormType m_type;
public:
	ICollisionForm(CObject* _owner, ECollisionFormType tp);
	virtual ~ICollisionForm();

	virtual BOOL _RayQuery(const collide::ray_defs& Q, collide::rq_results& R) = 0;
	//virtual void _BoxQuery ( const Fbox& B, const Fmatrix& M, u32 flags) = 0;

	IC CObject* Owner() const { return owner; }
	const Fbox& getBBox() const { return bv_box; }
	float getRadius() const { return bv_sphere.R; }
	const Fsphere& getSphere() const { return bv_sphere; }
	const ECollisionFormType Type() const { return m_type; }
};

struct SElement
{  
  Fmatrix b_IM; // world 2 bone xform
  Fvector b_hsize;
  Fsphere s_sphere;
  Fcylinder c_cylinder;
  u16 type;
  u16 elem_id;
  
  SElement() : elem_id(u16(-1)), type(0);
  SElement(u16 id, u16 t) : elem_id(id), type(t);
  BOOL valid() const;
  void center(Fvector& center) const;
};

class CCF_Skeleton : public ICollisionForm
{
public:
	DEFINE_VECTOR(SElement, ElementVec, ElementVecIt);
  
public:
	CCF_Skeleton(CObject* _owner);
	virtual BOOL _RayQuery(const collide::ray_defs& Q, collide::rq_results& R);
	bool _ElementCenter(u16 elem_id, Fvector& e_center);
	const ElementVec& _GetElements();
  void _dbg_refresh();
  
private:
	u64 vis_mask;
	ElementVec elements;
	u32 dwFrame; // The model itself
	u32 dwFrameTL; // Top level
  
private:
	void BuildState();
	void BuildTopLevel();
};

class CCF_EventBox : public ICollisionForm
{
private:
	Fplane Planes[6];
  
public:
	CCF_EventBox(CObject* _owner);
	virtual BOOL _RayQuery(const collide::ray_defs& Q, collide::rq_results& R);
	BOOL Contact(CObject* O);
};

struct shape_def
{
  int type;
  shape_data data;
};

class CCF_Shape : public ICollisionForm
{
public:  
  Fmatrix box;
	Fmatrix ibox;
  Fsphere sphere;
	xr_vector<shape_def> shapes;
  
public:
	CCF_Shape(CObject* _owner);
	virtual BOOL _RayQuery(const collide::ray_defs& Q, collide::rq_results& R);
	void add_sphere(Fsphere& S);
	void add_box(Fmatrix& B);
	void ComputeBounds();
	BOOL Contact(CObject* O);
	xr_vector<shape_def>& Shapes();
};

struct STranspParam
{
	Fvector P;
	Fvector D;
	float f;
	collide::ray_cache* pray_cache;
	float vis;
	float vis_threshold;

	STranspParam(collide::ray_cache* p, const Fvector& _P, const Fvector& _D, float _f, float _vis_threshold) :
		P(_P), D(_D), f(_f), pray_cache(p), vis(1.f), vis_threshold(_vis_threshold);
};


struct SSource : public SFlare
{
  BOOL ignore_color;
};

struct SFlare
{
  float fOpacity;
  float fRadius;
  float fPosition;
  shared_str texture;
  shared_str shader;
  FactoryPtr<IFlareRender> m_pRender;
  SFlare();
};

enum
{
  flFlare = (1 << 0),
  flSource = (1 << 1),
  flGradient = (1 << 2)
};

class CLensFlareDescriptor
{
public:
	DEFINE_VECTOR(SFlare, FlareVec, FlareIt);
	FlareVec m_Flares;
	Flags32 m_Flags;
	SSource m_Source;
	SFlare m_Gradient;
  shared_str section;
	float m_StateBlendUpSpeed;
	float m_StateBlendDnSpeed;
  
public:
	CLensFlareDescriptor();
	void load(CInifile* pIni, LPCSTR section);
	void OnDeviceCreate();
	void OnDeviceDestroy();
  void SetGradient(float fMaxRadius, float fOpacity, LPCSTR tex_name, LPCSTR sh_name);
	void SetSource(float fRadius, BOOL ign_color, LPCSTR tex_name, LPCSTR sh_name);
	void AddFlare(float fRadius, float fOpacity, float fPosition, LPCSTR tex_name, LPCSTR sh_name);
};

DEFINE_VECTOR(CLensFlareDescriptor*, LensFlareDescVec, LensFlareDescIt);

enum LFState
{
  lfsNone,
  lfsIdle,
  lfsHide,
  lfsShow,
};

class CLensFlare
{
public:
	const u32 MAX_RAYS = 5;

public:
	CLensFlare();
	virtual ~CLensFlare();
	void OnFrame(shared_str id);
	void __fastcall Render(BOOL bSun, BOOL bFlares, BOOL bGradient);
	void OnDeviceCreate();
	void OnDeviceDestroy();
	shared_str AppendDef(CEnvironment& environment, CInifile* pIni, LPCSTR sect);
	void Invalidate();
  
protected:
	float fBlend;
	u32 dwFrame;
	Fvector vSunDir;
	Fvector vecLight;
	Fvector vecX, vecY, vecDir, vecAxis, vecCenter;
	BOOL bRender;
	Fcolor LightColor;
	float fGradientValue;
	FactoryPtr<ILensFlareRender> m_pRender;
	LensFlareDescVec m_Palette;
	CLensFlareDescriptor* m_Current;
  LFState m_State;
	float m_StateBlend;
  
private:
  friend class dxLensFlareRender;
	collide::rq_results r_dest;
	collide::ray_cache m_ray_cache[MAX_RAYS];
};

enum
{
  COUNT_MOUSE_BUTTONS = 8,
  COUNT_MOUSE_AXIS = 3,
  COUNT_KB_BUTTONS = 256
};

struct sxr_mouse
{
  DIDEVCAPS capabilities;
  DIDEVICEINSTANCE deviceInfo;
  DIDEVICEOBJECTINSTANCE objectInfo;
  u32 mouse_dt;
};

struct sxr_key
{
  DIDEVCAPS capabilities;
  DIDEVICEINSTANCE deviceInfo;
  DIDEVICEOBJECTINSTANCE objectInfo;
};


class CInput : public pureFrame, public pureAppActivate, public pureAppDeactivate
{
public:
	sxr_mouse mouse_property;
	sxr_key key_property;
	u32 dwCurTime;

public:
  void resetMouseState();
	void SetAllAcquire(BOOL bAcquire = TRUE);
	void SetMouseAcquire(BOOL bAcquire);
	void SetKBDAcquire(BOOL bAcquire);
	void iCapture(IInputReceiver* pc);
	void iRelease(IInputReceiver* pc);
	BOOL iGetAsyncKeyState(int dik);
	BOOL iGetAsyncBtnState(int btn);
	void iGetLastMouseDelta(Ivector2& p);
	CInput(BOOL bExclusive = true, int deviceForInit = default_key);
	~CInput();
	virtual void _BCL OnFrame(void);
	virtual void OnAppActivate(void);
	virtual void OnAppDeactivate(void);
	void DeactivateSoft();
	IInputReceiver* CurrentIR();
	void exclusive_mode(const bool& exclusive);
	bool get_exclusive_mode();
	void unacquire();
	void acquire(const bool& exclusive);
	bool get_dik_name(int dik, LPSTR dest, int dest_sz);
	void feedback(u16 s1, u16 s2, float time);
  
private:
	BENCH_SEC_SCRAMBLEMEMBER1
	LPDIRECTINPUT8 pDI; // The DInput object
	LPDIRECTINPUTDEVICE8 pMouse; // The DIDevice7 interface
	LPDIRECTINPUTDEVICE8 pKeyboard; // The DIDevice7 interface
	u32 timeStamp[COUNT_MOUSE_AXIS];
	u32 timeSave[COUNT_MOUSE_AXIS];
	int offs[COUNT_MOUSE_AXIS];
	BOOL mouseState[COUNT_MOUSE_BUTTONS];
	BOOL KBState[COUNT_KB_BUTTONS];
  xr_vector<IInputReceiver*> cbStack;

private:
	HRESULT CreateInputDevice(LPDIRECTINPUTDEVICE8* device, GUID guidDevice, const DIDATAFORMAT* pdidDataFormat, u32 dwFlags, u32 buf_size);
	void MouseUpdate();
	void KeyUpdate();
};

class CCC_Quit : public IConsole_Command
{
public:
	CCC_Quit(LPCSTR N) : IConsole_Command(N);
	virtual void Execute(LPCSTR args);
};

class CCC_DbgStrCheck : public IConsole_Command
{
public:
	CCC_DbgStrCheck(LPCSTR N) : IConsole_Command(N);
	virtual void Execute(LPCSTR args);
};

class CCC_DbgStrDump : public IConsole_Command
{
public:
	CCC_DbgStrDump(LPCSTR N) : IConsole_Command(N);
	virtual void Execute(LPCSTR args);
};

class CCC_MotionsStat : public IConsole_Command
{
public:
	CCC_MotionsStat(LPCSTR N) : IConsole_Command(N);
	virtual void Execute(LPCSTR args);
};

class CCC_TexturesStat : public IConsole_Command
{
public:
	CCC_TexturesStat(LPCSTR N) : IConsole_Command(N);
	virtual void Execute(LPCSTR args);
};

class CCC_E_Dump : public IConsole_Command
{
public:
	CCC_E_Dump(LPCSTR N) : IConsole_Command(N);
	virtual void Execute(LPCSTR args);
};

class CCC_E_Signal : public IConsole_Command
{
public:
	CCC_E_Signal(LPCSTR N) : IConsole_Command(N);
	virtual void Execute(LPCSTR args);
};

class CCC_Help : public IConsole_Command
{
public:
	CCC_Help(LPCSTR N) : IConsole_Command(N);
	virtual void Execute(LPCSTR args);
};

class CCC_DumpOpenFiles : public IConsole_Command
{
public:
	CCC_DumpOpenFiles(LPCSTR N) : IConsole_Command(N);
	virtual void Execute(LPCSTR args);
};

class CCC_SaveCFG : public IConsole_Command
{
public:
	CCC_SaveCFG(LPCSTR N) : IConsole_Command(N);
	virtual void Execute(LPCSTR args);
};

class CCC_Start : public IConsole_Command
{
public:
	CCC_Start(LPCSTR N) : IConsole_Command(N);
	virtual void Execute(LPCSTR args);
  
private:
	void parse(LPSTR dest, LPCSTR args, LPCSTR name);
	void protect_Name_strlwr(LPSTR str);
};

class CCC_Disconnect : public IConsole_Command
{
public:
	CCC_Disconnect(LPCSTR N) : IConsole_Command(N);
	virtual void Execute(LPCSTR args);
};

class CCC_PART_Export : public IConsole_Command
{
public:
	CCC_PART_Export(LPCSTR N) : IConsole_Command(N);
	virtual void Execute(LPCSTR args);
};

class CCC_PART_Import : public IConsole_Command
{
public:
	CCC_PART_Import(LPCSTR N) : IConsole_Command(N);
	virtual void Execute(LPCSTR args);
};

class CCC_VID_Reset : public IConsole_Command
{
public:
	CCC_VID_Reset(LPCSTR N) : IConsole_Command(N);
	virtual void Execute(LPCSTR args);
};

class CCC_VidMode : public CCC_Token
{
private:
	u32 _dummy;
  
public:
	CCC_VidMode(LPCSTR N) : CCC_Token(N, &_dummy, NULL);
	virtual void Execute(LPCSTR args);
	virtual void Status(TStatus& S);
	virtual xr_token* GetToken();
	virtual void Info(TInfo& I);
	virtual void fill_tips(vecTips& tips, u32 mode);
};

class CCC_Screenmode : public CCC_Token
{
public:
	CCC_Screenmode(LPCSTR N) : CCC_Token(N, &g_screenmode, screen_mode_tokens);
	virtual void Execute(LPCSTR args);
};

class CCC_SND_Restart : public IConsole_Command
{
public:
	CCC_SND_Restart(LPCSTR N) : IConsole_Command(N);
	virtual void Execute(LPCSTR args);
};

class CCC_Gamma : public CCC_Float
{
public:
	CCC_Gamma(LPCSTR N, float* V) : CCC_Float(N, V, 0.5f, 1.5f);
	virtual void Execute(LPCSTR args);
};

class CCC_ScopeFactor : public CCC_Float
{
public:
	CCC_ScopeFactor(LPCSTR N, float* V) : CCC_Float(N, V, 0.01f, 1.0f);
	virtual void Execute(LPCSTR args);
};

class CCC_r2 : public CCC_Token
{
private:
	typedef CCC_Token inherited;
  
public:
	CCC_r2(LPCSTR N) : inherited(N, &renderer_value, NULL);
	virtual ~CCC_r2();
	virtual void Execute(LPCSTR args);
	virtual void Status(TStatus& S);
	virtual void Save(IWriter* F);
	virtual xr_token* GetToken();
};

class CCC_soundDevice : public CCC_Token
{
private:
	typedef CCC_Token inherited;
  
public:
	CCC_soundDevice(LPCSTR N) : inherited(N, &snd_device_id, NULL);
	virtual ~CCC_soundDevice();
	virtual void Execute(LPCSTR args);
	virtual void Status(TStatus& S);
	virtual xr_token* GetToken();
	virtual void Save(IWriter* F);
};

class CCC_ExclusiveMode : public IConsole_Command
{
private:
	typedef IConsole_Command inherited;

public:
	CCC_ExclusiveMode(LPCSTR N) :	inherited(N);
	virtual void Execute(LPCSTR args);
	virtual void Save(IWriter* F);
};

class CCC_HideConsole : public IConsole_Command
{
public:
	CCC_HideConsole(LPCSTR N) : IConsole_Command(N);
	virtual void Execute(LPCSTR args);
	virtual void Status(TStatus& S);
	virtual void Info(TInfo& I);
};

class CCC_SoundParamsSmoothing : public CCC_Integer
{
public:
	CCC_SoundParamsSmoothing(LPCSTR N, int* V, int _min = 0, int _max = 999) : CCC_Integer(N, V, _min, _max);
	virtual void Execute(LPCSTR args);
};

class IConsole_Command
{
public:
	friend class CConsole;
  
	typedef char TInfo[256];
	typedef char TStatus[256];
	typedef xr_vector<shared_str> vecTips;
	typedef xr_vector<shared_str> vecLRU;
  
public:
	IConsole_Command(LPCSTR N BENCH_SEC_SIGN) :	cName(N),	bEnabled(TRUE),	bLowerCaseArgs(TRUE),	bEmptyArgsHandled(FALSE);
	virtual ~IConsole_Command();
	LPCSTR Name();
	void InvalidSyntax();
	virtual void Execute(LPCSTR args) = 0;
	virtual void Status(TStatus& S);
	virtual void Info(TInfo& I);
	virtual void Save(IWriter* F);
	virtual void fill_tips(vecTips& tips, u32 mode);
	virtual void add_to_LRU(shared_str const& arg);
	void add_LRU_to_tips(vecTips& tips);
  
protected:
	LPCSTR cName;
	bool bEnabled;
	bool bLowerCaseArgs;
	bool bEmptyArgsHandled;
	vecLRU m_LRU;
  const u32 LRU_MAX_COUNT = 10;
	bool EQ(LPCSTR S1, LPCSTR S2);
};

class CCC_Mask : public IConsole_Command
{
public:
	CCC_Mask(LPCSTR N, Flags32* V, u32 M) :	IConsole_Command(N),	value(V),	mask(M);
	const BOOL GetValue() const;
	virtual void Execute(LPCSTR args);
	virtual void Status(TStatus& S);
	virtual void Info(TInfo& I);
	virtual void fill_tips(vecTips& tips, u32 mode);
  
protected:
	Flags32* value;
	u32 mask;
};

class CCC_ToggleMask : public IConsole_Command
{  
public:
	CCC_ToggleMask(LPCSTR N, Flags32* V, u32 M) : IConsole_Command(N), value(V),	mask(M);
	const BOOL GetValue() const;
	virtual void Execute(LPCSTR args);
	virtual void Status(TStatus& S);
	virtual void Info(TInfo& I);
	virtual void fill_tips(vecTips& tips, u32 mode);
  
protected:
	Flags32* value;
	u32 mask;
};

class CCC_Token : public IConsole_Command
{  
public:
	CCC_Token(LPCSTR N, u32* V, xr_token* T) : IConsole_Command(N), value(V),	tokens(T);
	virtual void Execute(LPCSTR args);
	virtual void Status(TStatus& S);
	virtual void Info(TInfo& I);
	virtual xr_token* GetToken();
	virtual void fill_tips(vecTips& tips, u32 mode);
  
protected:
	u32* value;
	xr_token* tokens;
};

class CCC_Float : public IConsole_Command
{  
public:
	CCC_Float(LPCSTR N, float* V, float _min = 0, float _max = 1) :	IConsole_Command(N), value(V),	min(_min), max(_max);
	const float GetValue() const;
	void GetBounds(float& fmin, float& fmax) const;
	virtual void Execute(LPCSTR args);
	virtual void Status(TStatus& S);
	virtual void Info(TInfo& I);
	virtual void fill_tips(vecTips& tips, u32 mode);
  
protected:
	float* value;
	float min, max;
};

class CCC_Vector3 : public IConsole_Command
{  
public:
	CCC_Vector3(LPCSTR N, Fvector* V, const Fvector _min, const Fvector _max) :	IConsole_Command(N),	value(V);
	const Fvector GetValue() const;
	Fvector* GetValuePtr() const;
	virtual void Execute(LPCSTR args);
	virtual void Status(TStatus& S);
	virtual void Info(TInfo& I);
	virtual void fill_tips(vecTips& tips, u32 mode);
  
protected:
	Fvector* value;
	Fvector min, max;
};

class CCC_Vector4 : public IConsole_Command
{  
public:
	CCC_Vector4(LPCSTR N, Fvector4* V, const Fvector4 _min, const Fvector4 _max) : IConsole_Command(N), value(V);
	const Fvector4 GetValue() const;
	Fvector4* GetValuePtr() const;
	virtual void Execute(LPCSTR args);
	virtual void Status(TStatus& S);
	virtual void Info(TInfo& I);
	virtual void fill_tips(vecTips& tips, u32 mode);
  
protected:
	Fvector4* value;
	Fvector4 min, max;
};

class CCC_IVector3 : public IConsole_Command
{  
public:
  CCC_IVector3(LPCSTR N, Ivector3* V, const Ivector3 _min, const Ivector3 _max) : IConsole_Command(N), value(V);
  const Ivector3 GetValue() const;
  Ivector3* GetValuePtr() const;
  virtual void Execute(LPCSTR args);
  virtual void Status(TStatus& S);
  virtual void Info(TInfo& I);
  virtual void fill_tips(vecTips& tips, u32 mode);
  
protected:
	Ivector3* value;
	Ivector3 min, max;
};

class CCC_IVector4 : public IConsole_Command
{
public:
  CCC_IVector4(LPCSTR N, Ivector4* V, const Ivector4 _min, const Ivector4 _max) :	IConsole_Command(N),	value(V);
  const Ivector4 GetValue() const;
  Ivector4* GetValuePtr() const;
  virtual void Execute(LPCSTR args);
  virtual void Status(TStatus& S);
  virtual void Info(TInfo& I);
  virtual void fill_tips(vecTips& tips, u32 mode);
  
protected:
	Ivector4* value;
	Ivector4 min, max;
};

class CCC_CrosshairColor : public CCC_IVector4
{
public:
	CCC_CrosshairColor(LPCSTR N, Ivector4* V, const Ivector4 _min, const Ivector4 _max) :	CCC_IVector4(N, V, _min, _max);
	virtual void Execute(LPCSTR args);
};

class CCC_Integer : public IConsole_Command
{  
public:
	const int GetValue() const;
	void GetBounds(int& imin, int& imax) const;
	CCC_Integer(LPCSTR N, int* V, int _min = 0, int _max = 999) : IConsole_Command(N), value(V), min(_min), max(_max);
	virtual void Execute(LPCSTR args);
	virtual void Status(TStatus& S);
	virtual void Info(TInfo& I);
	virtual void fill_tips(vecTips& tips, u32 mode);
  
protected:
	int* value;
	int min, max;
};

class CCC_String : public IConsole_Command
{
public:
	CCC_String(LPCSTR N, LPSTR V, int _size = 2) : IConsole_Command(N), value(V),	size(_size);
	virtual void Execute(LPCSTR args);
	virtual void Status(TStatus& S);
	virtual void Info(TInfo& I);
	virtual void fill_tips(vecTips& tips, u32 mode);
  
protected:
	LPSTR value;
	int size;
};

class CCC_LoadCFG : public IConsole_Command
{
public:
	virtual bool allow(LPCSTR cmd) { return true; };
	CCC_LoadCFG(LPCSTR N);
	virtual void Execute(LPCSTR args);
};

class CCC_LoadCFG_custom : public CCC_LoadCFG
{
private:
	string64 m_cmd;
  
public:
	CCC_LoadCFG_custom(LPCSTR cmd);
	virtual bool allow(LPCSTR cmd);
};

struct TipString
{
	shared_str text;
	int HL_start; // Highlight
	int HL_finish;

	TipString();
	TipString(shared_str const& tips_text, int start_pos, int finish_pos);
	TipString(LPCSTR tips_text, int start_pos, int finish_pos);
	TipString(shared_str const& tips_text);
	bool operator==(shared_str const& tips_text);
};

enum Console_mark
{
	no_mark = ' ',
	mark0 = '~',
	mark1 = '!',
	mark2 = '@',
	mark3 = '#',
	mark4 = '$',
	mark5 = '%',
	mark6 = '^',
	mark7 = '&',
	mark8 = '*',
	mark9 = '-',
	mark10 = '+',
	mark11 = '=',
	mark12 = '/'
};

struct str_pred
{
  bool operator()(const char* x, const char* y) const;
};

class CConsole : public pureRender, public pureFrame,	public pureScreenResolutionChanged
{
public:
	typedef xr_map<LPCSTR, IConsole_Command*, str_pred> vecCMD;
	typedef vecCMD::iterator vecCMD_IT;
	typedef vecCMD::const_iterator vecCMD_CIT;
	typedef fastdelegate::FastDelegate0<void> Callback;
	typedef xr_vector<shared_str> vecHistory;
	typedef xr_vector<shared_str> vecTips;
	typedef xr_vector<TipString> vecTipsEx;
  
  const u32 CONSOLE_BUF_SIZE = 1024;
  const u32 VIEW_TIPS_COUNT = 14;
  const u32 MAX_TIPS_COUNT = 220;

public:
	CConsole();
	virtual ~CConsole();
	virtual void Initialize();
	virtual void Destroy();
	virtual void OnRender();
	virtual void _BCL OnFrame();
	virtual void OnScreenResolutionChanged();
	string64 ConfigFile;
	bool bVisible;
	vecCMD Commands;
	void AddCommand(IConsole_Command* cc);
	void RemoveCommand(IConsole_Command* cc);
	void Show();
	void Hide();
	void Execute(LPCSTR cmd);
	void ExecuteScript(LPCSTR str);
	void ExecuteCommand(LPCSTR cmd, bool record_cmd = true);
	void SelectCommand();
	bool GetBool(LPCSTR cmd) const;
	float GetFloat(LPCSTR cmd, float& min, float& max) const;
	int GetInteger(LPCSTR cmd, int& min, int& max) const;
	LPCSTR GetString(LPCSTR cmd) const;
	LPCSTR GetToken(LPCSTR cmd) const;
	xr_token* GetXRToken(LPCSTR cmd) const;
	Fvector GetFVector(LPCSTR cmd) const;
	Fvector* GetFVectorPtr(LPCSTR cmd) const;
	IConsole_Command* GetCommand(LPCSTR cmd) const;

protected:
	text_editor::line_editor* m_editor;
  int scroll_delta;
	CGameFont* pFont;
	CGameFont* pFont2;
	FactoryPtr<IUIShader>* m_hShader_back;
	POINT m_mouse_pos;
	bool m_disable_tips;
  
protected:
	text_editor::line_edit_control& ec();
	bool is_mark(Console_mark type);
	u32 get_mark_color(Console_mark type);
	void DrawBackgrounds(bool bGame);
	void DrawRect(Frect const& r, u32 color);
	void OutFont(LPCSTR text, float& pos_y);
	void Register_callbacks();
	void xr_stdcall Screenshot();
	void xr_stdcall Prev_log();
	void xr_stdcall Next_log();
	void xr_stdcall Begin_log();
	void xr_stdcall End_log();
	void xr_stdcall Find_cmd();
	void xr_stdcall Find_cmd_back();
	void xr_stdcall Prev_cmd();
	void xr_stdcall Next_cmd();
	void xr_stdcall Prev_tip();
	void xr_stdcall Next_tip();
	void xr_stdcall Begin_tips();
	void xr_stdcall End_tips();
	void xr_stdcall PageUp_tips();
	void xr_stdcall PageDown_tips();
	void xr_stdcall Execute_cmd();
	void xr_stdcall Show_cmd();
	void xr_stdcall Hide_cmd();
	void xr_stdcall Hide_cmd_esc();
	void xr_stdcall GamePause();
	void add_cmd_history(shared_str const& str);
	void next_cmd_history_idx();
	void prev_cmd_history_idx();
	void reset_cmd_history_idx();
	void next_selected_tip();
	void check_next_selected_tip();
	void prev_selected_tip();
	void check_prev_selected_tip();
	void reset_selected_tip();
	IConsole_Command* find_next_cmd(LPCSTR in_str, shared_str& out_str);
	bool add_next_cmds(LPCSTR in_str, vecTipsEx& out_v);
	bool add_internal_cmds(LPCSTR in_str, vecTipsEx& out_v);
	void update_tips();
	void select_for_filter(LPCSTR filter_str, vecTips& in_v, vecTipsEx& out_v);
  
private:
	vecHistory m_cmd_history;
	u32 m_cmd_history_max;
	int m_cmd_history_idx;
	shared_str m_last_cmd;
	vecTips m_temp_tips;
	vecTipsEx m_tips;
	u32 m_tips_mode;
	shared_str m_cur_cmd;
	int m_select_tip;
	int m_start_tip;
	u32 m_prev_length_str;
};

struct SavedPosition
{
  u32 dwTime;
  Fvector vPosition;
};

struct storage
{
  u32 net_ID : 16;
  u32 bActiveCounter : 8;
  u32 bEnabled : 1;
  u32 bVisible : 1;
  u32 bDestroy : 1;
  u32 net_Local : 1;
  u32 net_Ready : 1;
  u32 net_SV_Update : 1;
  u32 crow : 1;
  u32 bPreDestroy : 1;
};


class CObject : public DLL_Pure, public ISpatial, public ISheduled,	public IRenderable,	public ICollidable
{
public:
  u32 dbg_update_cl;
	u32 dwFrame_UpdateCL;
	u32 dwFrame_AsCrow;  
  
public:
  void DBGGetProps(ObjectProperties& p) const;
	void MakeMeCrow();
	void IAmNotACrowAnyMore();
	virtual BOOL AlwaysTheCrow();
	bool AmICrow() const;
	BOOL Local() const;
	BOOL Remote() const;
	u16 ID() const;
	void setID(u16 _ID);
	virtual BOOL Ready();
	BOOL GetTmpPreDestroy() const;
	void SetTmpPreDestroy(BOOL b);
	virtual float shedule_Scale();
	virtual bool shedule_Needed();
	CObject* H_Parent();
	const CObject* H_Parent() const;
	CObject* H_Root();
	const CObject* H_Root() const;
	CObject* H_SetParent(CObject* O, bool just_before_destroy = false);
	virtual void Center(Fvector& C) const;
	const Fmatrix& XFORM() const;
	Fmatrix& XFORM();
	virtual void spatial_register();
	virtual void spatial_unregister();
	virtual void spatial_move();
	void spatial_update(float eps_P, float eps_R);
	Fvector& Direction();
	const Fvector& Direction() const;
	Fvector& Position();
	const Fvector& Position() const;
	virtual float Radius() const;
	virtual const Fbox& BoundingBox() const;
	IRender_Sector* Sector();
	IRender_ObjectSpecific* ROS();
	virtual BOOL renderable_ShadowGenerate();
	virtual BOOL renderable_ShadowReceive();
	IRenderVisual* Visual() const;
	ICollisionForm* CFORM() const;
	virtual CObject* dcast_CObject();
	virtual IRenderable* dcast_Renderable();
	virtual void OnChangeVisual();
	virtual IPhysicsShell* physics_shell();
	virtual const IObjectPhysicsCollision* physics_collision();
	shared_str cName() const;
	void cName_set(shared_str N);
	shared_str cNameSect() const;
	LPCSTR cNameSect_str() const;
	void cNameSect_set(shared_str N);
	shared_str cNameVisual() const;
	void cNameVisual_set(shared_str N);
	virtual shared_str shedule_Name() const;
	void processing_activate();
	void processing_deactivate();
	bool processing_enabled();
	void setVisible(BOOL _visible);
	BOOL getVisible() const;
	void setEnabled(BOOL _enabled);
	BOOL getEnabled() const;
	void setDestroy(BOOL _destroy);
	BOOL getDestroy() const;
	void setLocal(BOOL _local);
	BOOL getLocal() const;
	void setSVU(BOOL _svu);
	BOOL getSVU() const;
	void setReady(BOOL _ready);
	BOOL getReady() const;
	CObject();
	virtual ~CObject();
	virtual void Load(LPCSTR section);
	virtual void shedule_Update(u32 dt); // Called by sheduler
	virtual void renderable_Render();
	virtual void UpdateCL(); // Called each frame, so no need for dt
	virtual BOOL net_Spawn(CSE_Abstract* data);
	virtual void net_Destroy();
	virtual void net_Export(NET_Packet& P);
	virtual void net_Import(NET_Packet& P);
	virtual void net_ImportInput(NET_Packet& P);
	virtual BOOL net_Relevant();
	virtual void net_MigrateInactive(NET_Packet& P);
	virtual void net_MigrateActive(NET_Packet& P);
	virtual void net_Relcase(CObject* O);
	u32 ps_Size() const;
	virtual SavedPosition ps_Element(u32 ID) const;
	virtual void ForceTransform(const Fmatrix& m);
	virtual void OnHUDDraw(CCustomHUD* hud);
	virtual void OnH_B_Chield(); // before
	virtual void OnH_B_Independent(bool just_before_destroy);
	virtual void OnH_A_Chield(); // after
	virtual void OnH_A_Independent();
	virtual void On_SetEntity();
	virtual void On_LostEntity();
	virtual bool register_schedule() const;
	virtual Fvector get_new_local_point_on_mesh(u16& bone_id) const;
	virtual Fvector get_last_local_point_on_mesh(Fvector const& last_point, u16 bone_id) const;
  
private:
	ObjectProperties Props;
	shared_str NameObject;
	shared_str NameSection;
	shared_str NameVisual;
  
protected:
	CObject* Parent;
	svector<SavedPosition, 4> PositionStack;
};

class fClassEQ
{  
public:
	fClassEQ(CLASS_ID C) : cls(C);
	bool operator()(CObject* O);
  
private:
	CLASS_ID cls;
};

struct SRelcasePair
{
  int* m_ID;
  RELCASE_CALLBACK m_Callback;

  SRelcasePair(int* id, RELCASE_CALLBACK cb) : m_ID(id), m_Callback(cb);
  bool operator==(RELCASE_CALLBACK cb);
};

class CObjectList
{
public:
	typedef fastdelegate::FastDelegate1<CObject*> RELCASE_CALLBACK;
	typedef xr_vector<SRelcasePair> RELCASE_CALLBACK_VEC;
	RELCASE_CALLBACK_VEC m_relcase_callbacks;	

public:
	CObjectList();
	~CObjectList();
  void relcase_register(RELCASE_CALLBACK, int*);
	void relcase_unregister(int*);
	CObject* FindObjectByName(shared_str name);
	CObject* FindObjectByName(LPCSTR name);
	CObject* FindObjectByCLS_ID(CLASS_ID cls);
	void Load();
	void Unload();
	CObject* Create(LPCSTR name);
	void Destroy(CObject* O);
	void SingleUpdate(CObject* O);
	void Update(bool bForce);
	void net_Register(CObject* O);
	void net_Unregister(CObject* O);
	u32 net_Export(NET_Packet* P, u32 _start, u32 _count); // return next start
	void net_Import(NET_Packet* P);
	CObject* net_Find(u16 ID) const;
	void o_crow(CObject* O);
	void o_remove(Objects& v, CObject* O);
	void o_activate(CObject* O);
	void o_sleep(CObject* O);
	u32 o_count();
	CObject* o_get_by_iterator(u32 _it);
	bool dump_all_objects();
	void register_object_to_destroy(CObject* object_to_destroy);
  bool registered_object_to_destroy(const CObject* object_to_destroy) const;

private:
	Objects& get_crows();
	static void clear_crow_vec(Objects& o);
	static void dump_list(Objects& v, LPCSTR reason);
  
private:
	CObject* map_NETID[0xffff];
	typedef xr_vector<CObject*> Objects;
	Objects destroy_queue;
	Objects objects_active;
	Objects objects_sleeping;
	Objects m_crows[2];
	u32 m_owner_thread_id;
};

typedef u32 Pixel;

struct Image
{
	int xsize; /* horizontal size of the image in Pixels */
	int ysize; /* vertical size of the image in Pixels */
	Pixel* data; /* pointer to first scanline of image */
	int span; /* byte offset between two scanlines */
};

struct CONTRIB
{
	int pixel;
	float weight;
};

struct CLIST
{
	int n; /* number of contributors */
	CONTRIB* p; /* pointer to _list_ of contributions */
};

enum EIMF_Type
{
	imf_filter = 0,
	imf_box,
	imf_triangle,
	imf_bell,
	imf_b_spline,
	imf_lanczos3,
	imf_mitchell,
	imf_FORCEDWORD = 0xffffffff
};

struct xrGUID
{
	u64 g[2];
	bool operator==(const xrGUID& o) const;
	bool operator!=(const xrGUID& o) const;
	void LoadLTX(CInifile& ini, LPCSTR section, LPCSTR name);
	void SaveLTX(CInifile& ini, LPCSTR section, LPCSTR name);
};

enum fsL_Chunks
{
	fsL_HEADER = 1,
	//*
	fsL_SHADERS = 2,
	//*
	fsL_VISUALS = 3,
	//*
	fsL_PORTALS = 4,
	//* - Portal polygons
	fsL_LIGHT_DYNAMIC = 6,
	//*
	fsL_GLOWS = 7,
	//* - All glows inside level
	fsL_SECTORS = 8,
	//* - All sectors on level
	fsL_VB = 9,
	//* - Static geometry
	fsL_IB = 10,
	//*
	fsL_SWIS = 11,
	//* - collapse info, usually for trees
	fsL_forcedword = 0xFFFFFFFF
};

enum fsESectorChunks
{
	fsP_Portals = 1,
	fsP_Root,
	fsP_forcedword = u32(-1)
};

enum fsSLS_Chunks
{
	fsSLS_Description = 1,
	fsSLS_ServerState,
	fsSLS_forcedword = u32(-1)
};

enum EBuildQuality
{
	ebqDraft = 0,
	ebqHigh,
	ebqCustom,
	ebq_force_u16 = u16(-1)
};

struct hdrLEVEL
{
	u16 XRLC_version;
	u16 XRLC_quality;
};

struct hdrCFORM
{
	u32 version;
	u32 vertcount;
	u32 facecount;
	Fbox aabb;
};

struct hdrNODES
{
	u32 version;
	u32 count;
	float size;
	float size_y;
	Fbox aabb;
	xrGUID guid;
};

class NodePosition
{
	u8 data[5];

	ICF void xz(u32 value)
	{
		CopyMemory(data, &value, 3);
	}

	ICF void y(u16 value)
	{
		CopyMemory(data + 3, &value, 2);
	}

public:
	ICF u32 xz() const
	{
		return ((*((u32*)data)) & 0x00ffffff);
	}

	ICF u32 x(u32 row) const
	{
		return (xz() / row);
	}

	ICF u32 z(u32 row) const
	{
		return (xz() % row);
	}

	ICF u32 y() const
	{
		return (*((u16*)(data + 3)));
	}

	friend class CLevelGraph;
	friend struct CNodePositionCompressor;
	friend struct CNodePositionConverter;
};

struct SCover
{
  u16 cover0 : 4;
  u16 cover1 : 4;
  u16 cover2 : 4;
  u16 cover3 : 4;
  u16 cover(u8 index) const;
};

struct NodeCompressed
{
public:
	u32 linknew(u8 index) const;
	u32 link(u8 index) const;
  
public:
	u8 data[12];
	SCover high;
	SCover low;
	u16 plane;
	NodePosition p;
	friend class CLevelGraph;
	friend struct CNodeCompressed;
	friend class CNodeRenumberer;
	friend class CRenumbererConverter;
  
private:
	void link(u8 link_index, u32 value);
	void linknew(u8 link_index, u32 value);
	void light(u8 value);
};

struct SNodePositionOld
{
	s16 x;
	u16 y;
	s16 z;
};

class xrSASH
{
public:
	xrSASH();
	~xrSASH();
	bool Init(const char* pszParam);
	void MainLoop();
	bool IsRunning();
	bool IsBenchmarkRunning();
	void StartBenchmark();
	void DisplayFrame(float t);
	void EndBenchmark();
	void OnConsoleInvalidSyntax(bool bLastLine, const char* pszMsg, ...);

private:
	void LoopOA();
	void LoopNative();
	void ReportNative(LPCSTR pszTestName);
	void GetAllOptions();
	void GetCurrentOptions();
	void SetOptions();
	void GetBenchmarks();
	void RunBenchmark(LPCSTR pszName);
	void TryInitEngine(bool bNoRun = true);
	void ReleaseEngine();

private:
	bool m_bInited;
	bool m_bOpenAutomate;
	bool m_bRunning;
	bool m_bBenchmarkRunning;
	bool m_bReinitEngine;
	bool m_bExecutingConsoleCommand;
	string64 m_strBenchCfgName;
	CTimer m_FrameTimer;
	xr_vector<float> m_aFrimeTimes;
};

struct Item
	{
		u32 dwTimeForExecute;
		u32 dwTimeOfLastExecute;
		shared_str scheduled_name;
		ISheduled* Object;
		u32 dwPadding;
		bool operator<(Item& I);
	};

	struct ItemReg
	{
		BOOL OP;
		BOOL RT;
		ISheduled* Object;
	};

class CSheduler
{  
public:
	u64 cycles_start;
	u64 cycles_limit;
  
public:
	void ProcessStep();
	void Process();
	void Update();
  bool Registered(ISheduled* object) const;
	void Register(ISheduled* A, BOOL RT = FALSE);
	void Unregister(ISheduled* A);
	void EnsureOrder(ISheduled* Before, ISheduled* After);
	void Initialize();
	void Destroy();
  
private:
	xr_vector<Item> ItemsRT;
	xr_vector<Item> Items;
	xr_vector<Item> ItemsProcessed;
	xr_vector<ItemReg> Registration;
	ISheduled* m_current_step_obj;
	bool m_processing_now;

private:
	void Push(Item& I);
	void Pop();
	Item& Top();
	void internal_Register(ISheduled* A, BOOL RT = FALSE);
	bool internal_Unregister(ISheduled* A, BOOL RT, bool warn_on_not_found = true);
	void internal_Registration();
};

class CTheoraStream
{  
public:
	CTheoraStream();
	virtual ~CTheoraStream();
	BOOL Load(const char* fname);
	void Reset();
	BOOL Decode(u32 tm_play);
	yuv_buffer* CurrentFrame();
  
private:
	friend class CTheoraSurface;

	ogg_sync_state o_sync_state;
	ogg_page o_page;
	ogg_stream_state o_stream_state;
	theora_info t_info;
	theora_comment t_comment;
	theora_state t_state;
	CStreamReader* source;
	yuv_buffer t_yuv_buffer;
	ogg_int64_t d_frame;
	u32 tm_total;
	u32 key_rate; // theora have const key rate
	float fpms;
  
protected:
	int ReadData();
	BOOL ParseHeaders();
};

class CTheoraSurface
{  
public:
	BOOL playing;
	BOOL looped;

public:
	CTheoraSurface();
	virtual ~CTheoraSurface();
	BOOL Valid();
	BOOL Load(const char* fname);
	BOOL Update(u32 _time);
	void DecompressFrame(u32* dst, u32 _width, int& count);
	void Play(BOOL _looped, u32 _time);
	void Pause(BOOL _pause);
	void Stop();
	BOOL IsPlaying();
	u32 Width(bool bRealSize);
	u32 Height(bool bRealSize);
  
protected:
	void Reset();
  
private:
	CTheoraStream* m_rgb;
	CTheoraStream* m_alpha;
	u32 tm_start;
	u32 tm_play;
	u32 tm_total;
	BOOL ready;
	BOOL bShaderYUV2RGB;
	int prefetch;
};

#define THUNDERBOLT_CACHE_SIZE 8
#define HUD_CROSSHAIR (1<<0)
#define HUD_CROSSHAIR_DIST (1<<1)
#define HUD_WEAPON (1<<2)
#define HUD_INFO (1<<3)
#define HUD_DRAW (1<<4)
#define HUD_CROSSHAIR_RT (1<<5)
#define HUD_WEAPON_RT (1<<6)
#define HUD_CROSSHAIR_DYNAMIC (1<<7)
#define HUD_CROSSHAIR_RT2 (1<<9)
#define HUD_DRAW_RT (1<<10)
#define HUD_WEAPON_RT2 (1<<11)
#define HUD_DRAW_RT2 (1<<12)
#define BI_NONE (u16(-1))
#define OGF_IKDATA_VERSION 0x0001
#define MAX_BONE_PARAMS 4
#define effCustomEffectorStartID 10000
#define bDebug 0
#define _game_data_ "$game_data$"
#define _game_textures_ "$game_textures$"
#define _game_levels_ "$game_levels$"
#define _game_sounds_ "$game_sounds$"
#define _game_meshes_ "$game_meshes$"
#define _game_shaders_ "$game_shaders$"
#define _game_config_ "$game_congif$"
#define _server_root_ "$server_root$"
#define _server_data_root_ "$server_data_root$"
#define _local_root_ "$local_root$"
#define _import_ "$import$"
#define _sounds_ "$sounds$"
#define _textures_ "$textures$"
#define _objects_ "$objects$"
#define _maps_ "$maps$"
#define _temp_ "$temp$"
#define _omotion_ "$omotion$"
#define _omotions_ "$omotions$"
#define _smotion_ "$smotion$"
#define _detail_objects_ "$detail_objects$"
#define R_VIEWPORT_NEAR 0.005f
#define DEVICE_RESET_PRECACHE_FRAME_COUNT 10
#define SHAPE_TCB 0
#define SHAPE_HERM 1
#define SHAPE_BEZI 2
#define SHAPE_LINE 3
#define SHAPE_STEP 4
#define SHAPE_BEZ2 5
#define BEH_RESET 0
#define BEH_CONSTANT 1
#define BEH_REPEAT 2
#define BEH_OSCILLATE 3
#define BEH_OFFSET 4
#define BEH_LINEAR 5
#define WFX_TRANS_TIME 5.f
#define DAY_LENGTH 86400.f
#define DISCORD_VERSION 2
#define DISCORD_APPLICATION_MANAGER_VERSION 1
#define DISCORD_USER_MANAGER_VERSION 1
#define DISCORD_IMAGE_MANAGER_VERSION 1
#define DISCORD_ACTIVITY_MANAGER_VERSION 1
#define DISCORD_RELATIONSHIP_MANAGER_VERSION 1
#define DISCORD_LOBBY_MANAGER_VERSION 1
#define DISCORD_NETWORK_MANAGER_VERSION 1
#define DISCORD_OVERLAY_MANAGER_VERSION 2
#define DISCORD_STORAGE_MANAGER_VERSION 1
#define DISCORD_STORE_MANAGER_VERSION 1
#define DISCORD_VOICE_MANAGER_VERSION 1
#define DISCORD_ACHIEVEMENT_MANAGER_VERSION 1
#define GAMEMTL_CURRENT_VERSION 0x0001
#define GAMEMTLS_CHUNK_VERSION 0x1000
#define GAMEMTLS_CHUNK_AUTOINC 0x1001
#define GAMEMTLS_CHUNK_MTLS 0x1002
#define GAMEMTLS_CHUNK_MTLS_PAIR 0x1003
#define GAMEMTL_CHUNK_MAIN 0x1000
#define GAMEMTL_CHUNK_FLAGS 0x1001
#define GAMEMTL_CHUNK_PHYSICS 0x1002
#define GAMEMTL_CHUNK_FACTORS 0x1003
#define GAMEMTL_CHUNK_FLOTATION 0x1004
#define GAMEMTL_CHUNK_DESC 0x1005
#define GAMEMTL_CHUNK_INJURIOUS 0x1006
#define GAMEMTL_CHUNK_DENSITY 0x1007
#define GAMEMTL_CHUNK_FACTORS_MP 0x1008
#define GAMEMTLPAIR_CHUNK_PAIR 0x1000
#define GAMEMTLPAIR_CHUNK_BREAKING 0x1002
#define GAMEMTLPAIR_CHUNK_STEP 0x1003
#define GAMEMTLPAIR_CHUNK_COLLIDE 0x1005
#define GAMEMTL_SUBITEM_COUNT 10
#define GAMEMTL_NONE_ID u32(-1)
#define GAMEMTL_NONE_IDX u16(-1)
#define GAMEMTL_FILENAME "gamemtl.xr"
#define LANIM_VERSION 0x0001
#define CHUNK_VERSION 0x0000
#define CHUNK_ITEM_LIST 0x0001
#define CHUNK_ITEM_COMMON 0x0001
#define CHUNK_ITEM_KEYS 0x0002
#define BITS1_MASK 0x80 // 10000000b
#define BITS2_MASK 0xC0 // 11000000b
#define BITS3_MASK 0xE0 // 11100000b
#define BITS4_MASK 0xF0 // 11110000b
#define BITS1_EXP 0x00 // 00000000b
#define BITS2_EXP 0x80 // 10000000b
#define BITS3_EXP 0xC0 // 11000000b
#define BITS4_EXP 0xE0 // 11100000b
#define MAX_MB_CHARS 4096
#define EOBJ_OMOTION 0x1100
#define EOBJ_SMOTION 0x1200
#define EOBJ_OMOTION_VERSION 0x0005
#define EOBJ_SMOTION_VERSION 0x0007
#define MP_DEBUG_AUTH 0x7ebf746e
#define SAMPLE_SIZE 256
#define P_MAXINT 0x7fffffff
#define REG_PRIORITY_LOW 0x11111111ul
#define REG_PRIORITY_NORMAL 0x22222222ul
#define REG_PRIORITY_HIGH 0x33333333ul
#define REG_PRIORITY_CAPTURE 0x7ffffffful
#define REG_PRIORITY_INVALID 0xfffffffful
#define IDDEBUG 3
#define IDD_STARTUP 106
#define IDI_ICON1 111
#define IDB_BITMAP2 116
#define IDB_BITMAP3 120
#define IDB_BITMAP1 123
#define IDC_LIST 1000
#define IDC_FILE 1001
#define IDC_LINE 1002
#define IDC_DESC 1003
#define IDSTOP 1004
#define IDC_STACK 1006
#define IDC_STATIC_LOGO 1007
#define RC_VIRT_MEM_ERROR 2071
#define RC_VIRT_MEM_TEXT 2072
#define CLSID_HUDMANAGER MK_CLSID('H','U','D','_','M','N','G','R')
#define CLSID_GAME_LEVEL MK_CLSID('G','_','L','E','V','E','L',' ')
#define CLSID_GAME_PERSISTANT MK_CLSID('G','_','P','E','R','S','I','S')
#define CLSID_OBJECT MK_CLSID('O','B','J','E','C','T',' ',' ')
#define DEFAULT_MODULE_HASH "3CAABCFCFF6F3A810019C6A72180F166"
#define BLEND_INC_SPEED 8.0f
#define BLEND_DEC_SPEED 4.0f
#define MOUSE_1 (0xED + 100)
#define MOUSE_8 (0xED + 107)
#define DIRECTINPUT_VERSION 0x0800
#define CROW_RADIUS (30.f)
#define CROW_RADIUS2 (60.f)
#define HEMI1_VERTS 26
#define HEMI1_FACES 40
#define HEMI2_VERTS 91
#define HEMI2_FACES 160
#define HEMI3_VERTS 196
#define WHITE_PIXEL (255)
#define BLACK_PIXEL (0)
#define filter_support (1.0)
#define box_support (0.5)
#define triangle_support (1.0)
#define bell_support (1.5)
#define B_spline_support (2.0)
#define Lanczos3_support (3.0)
#define Mitchell_support (2.0)
#define B (1.0f / 3.0f)
#define C (1.0f / 3.0f)

float ps_gamma = 1.f, ps_brightness = 1.f, ps_contrast = 1.f;
static char szEngineHash[33] = DEFAULT_MODULE_HASH;
float psCamInert = 0.f;
float psCamSlideInert = 0.25f;
u32 psCurrentBPP = 32;
int psTextureLOD = 1;
float refresh_rate = 0;
volatile u32 mt_Thread_marker = 0x12345678;
int g_svDedicateServerUpdateReate = 100;
u32 app_inactive_time = 0;
u32 app_inactive_time_start = 0;
float psVisDistance = 1.f;
static const float MAX_NOISE_FREQ = 0.03f;
const float MAX_DIST_FACTOR = 0.95f;
const float fuzzy_update_vis = 1000.f; // speed of fuzzy-logic desisions
const float fuzzy_update_novis = 1000.f; // speed of fuzzy-logic desisions
const float fuzzy_guaranteed = 0.001f; // distance which is supposed 100% visible
const float lr_granularity = 0.1f; // assume similar positions
const u16 xrOGF_SMParamsVersion = 4;
const u8 xrOGF_FormatVersion = 4;
int psNET_DedicatedSleep = 5;
float g_console_sensitive = 0.15f;
static const int max_desired_items = 2500;
static const float source_radius = 12.5f;
static const float source_offset = 20.f; // 40
static const float max_distance = source_offset * 1.5f;//1.25f;
static const float sink_offset = -(max_distance - source_offset);
static const float drop_length = 5.f;
static const float drop_width = 0.30f;
static const float drop_angle = deg2rad(15.0f); // 3.0
static const float drop_max_angle = deg2rad(35.f); // 10
static const float drop_max_wind_vel = 20.0f;
static const float drop_speed_min = 40.f;
static const float drop_speed_max = 80.f;
const int max_particles = 1000;
const int particles_cache = 400;
const float particles_time = .3f;
const u32 MAX_PARTS = 4;
const f32 SAMPLE_FPS = 30.f;
const f32 SAMPLE_SPF = (1.f / SAMPLE_FPS);
f32 const END_EPS = SAMPLE_SPF + EPS;
const f32 KEY_Quant = 32767.f;
const f32 KEY_QuantI = 1.f / KEY_Quant;
const float fQuantizerRangeExt = 1.5f;
int g_ErrorLineCount = 15;
int g_svTextConsoleUpdateRate = 1;
BOOL g_bIntroFinished = FALSE;
float discord_update_rate = .5f;
bool use_reshade = false;
static LPSTR month_id[12] =
{
	"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};
static int days_in_month[12] =
{
	31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
};
static int start_day = 31; // 31
static int start_month = 1; // January
static int start_year = 1999; // 1999
const u32 clGET_TRIS = (1 << 0);
const u32 clGET_BOXES = (1 << 1);
const u32 clGET_SPHERES = (1 << 2);
const u32 clQUERY_ONLYFIRST = (1 << 3); // stop if was any collision
const u32 clQUERY_TOPLEVEL = (1 << 4); // get only top level of model box/sphere
const u32 clQUERY_STATIC = (1 << 5); // static
const u32 clQUERY_DYNAMIC = (1 << 6); // dynamic
const u32 clCOARSE = (1 << 7); // coarse test (triangles vs obb)
float psMouseSens = 1.f;
float psMouseSensScale = 1.f;
Flags32 psMouseInvert = {FALSE};
float stop_vibration_time = flt_max;
int MOUSEBUFFERSIZE = 1024;
int KEYBOARDBUFFERSIZE = 128;
static bool g_exclusive = false;
BOOL b_altF4 = FALSE;
const int mouse_device_key = 1;
const int keyboard_device_key = 2;
const int all_device_key = mouse_device_key | keyboard_device_key;
const int default_key = mouse_device_key | keyboard_device_key;
u32 g_screenmode = 1;
BOOL r2_sun_static = TRUE;
BOOL r2_advanced_pp = FALSE;
u32 renderer_value = 3;
float psHUD_FOV_def = 0.45f;
float psHUD_FOV = psHUD_FOV_def;
int ps_r__Supersample = 1;
float ps_r2_sun_shafts_min = 0.f;
float ps_r2_sun_shafts_value = 1.f;
float hit_modifier = 1.0f;
float g_AimLookFactor = 1.f;
int ps_framelimiter = 0;
float g_ironsights_factor = 1.25f;
float scope_fog_interp = 0.15f;
float scope_fog_travel = 0.25f;
float scope_fog_attack = 0.66f;
float scope_fog_mattack = 0.25f;
float scope_ca = 0.003f;
float scope_outerblur = 1.0f;
float scope_innerblur = 0.1f;
float scope_scrollpower = 0.66f;
float scope_brightness = 1.0f;
float scope_radius = 0.f;
float scope_fog_radius = 1.25f;
float scope_fog_sharp = 4.0f;
int scope_2dtexactive = 0.0;
Fvector3 ssfx_wetness_multiplier = Fvector3().set(1.0f, 0.3f, 0.0f);
static float const UI_BASE_WIDTH = 1024.0f;
static float const UI_BASE_HEIGHT = 768.0f;
static float const LDIST = 0.05f;
static u32 const cmd_history_max = 64;
static u32 const prompt_font_color = color_rgba(228, 228, 255, 255);
static u32 const tips_font_color = color_rgba(230, 250, 230, 255);
static u32 const cmd_font_color = color_rgba(138, 138, 245, 255);
static u32 const cursor_font_color = color_rgba(255, 255, 255, 255);
static u32 const total_font_color = color_rgba(250, 250, 15, 180);
static u32 const default_font_color = color_rgba(250, 250, 250, 250);
static u32 const back_color = color_rgba(20, 20, 20, 200);
static u32 const tips_back_color = color_rgba(20, 20, 20, 200);
static u32 const tips_select_color = color_rgba(90, 90, 140, 230);
static u32 const tips_word_color = color_rgba(5, 100, 56, 200);
static u32 const tips_scroll_back_color = color_rgba(15, 15, 15, 230);
static u32 const tips_scroll_pos_color = color_rgba(70, 70, 70, 240);
char const* const ioc_prompt = ">>> ";
char const* const ch_cursor = "_";
const float base_spu_epsP = 0.05f;
const float base_spu_epsR = 0.05f;
int g_Dump_Export_Obj = 0;
const u32 XRCL_CURRENT_VERSION = 18; //17; // input
const u32 XRCL_PRODUCTION_VERSION = 14; // output
const u32 CFORM_CURRENT_VERSION = 4;
const u32 MAX_NODE_BIT_COUNT = 24;
const u32 XRAI_CURRENT_VERSION = 10;
float psShedulerCurrent = 10.f;
float psShedulerTarget = 10.f;
const float psShedulerReaction = 0.1f;
BOOL g_bSheduleInProgress = FALSE;
